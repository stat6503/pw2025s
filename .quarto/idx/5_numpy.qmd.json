{"title":"5.1. 넘파이 배열","markdown":{"yaml":{"jupyter":"python3"},"headingText":"5.1. 넘파이 배열","containsRefs":false,"markdown":"\n\n<h1>5. NumPy</h1>\n<br>\n\n### 5.1.1. 넘파이 배열 생성\n+ NumPy\n  + Numerical Python의 약자로, C언어로 구현된 Python 라이브러리\n  + 고성능 수치 계산, 대규모 다차원 배열 및 행렬 연산에 최적화\n\n<br>\n\n+ 넘파이 배열(ndarray)\n  + 리스트처럼 데이터를 모아 저장하는 자료구조\n  + **모든 원소가 동일한 자료형**으로 저장(효율적인 메모리 관리 및 빠른 연산)\n  + 대규모 데이터 처리에 유리함\n  + 반복문 없이 배열 간 연산이 가능한 브로드캐스팅 및 벡터화 연산 지원\n  + 다양한 수학 함수, 선형대수, 난수 생성 기능 제공\n\n<br>\n\n|함수|설명|\n|:---:|:------------|\n|np.array()|리스트, 튜플 등으로부터 배열 생성|\n|np.zeros()|모든 값이 0인 배열 생성|\n|np.ones()|모든 값이 1인 배열 생성|\n|np.full()|지정한 값으로 이루어진 배열 생성|\n|np.arange()|범위를 지정하여 연속적인 값의 배열 생성(`range()`와 비슷)|\n|np.linspace()|시작과 끝을 기준으로, 지정한 개수만큼 일정 간격의 값으로 배열 생성|\n|np.eye()|행과 열의 크기를 지정할 수 있는 단위행렬(2차원 배열) 생성|\n|np.identity()|정방 단위행렬(2차원 배열) 생성|\n\n<br>\n\n```{python}\nimport numpy as np\n```\n\n```{python}\n# 넘파이 배열 생성1\narr1 = np.array([1, 2, 3])\narr2 = np.array((6, 7, 8, 9))\nprint(arr1)\nprint(arr2)\n```\n\n```{python}\n# 넘파이 배열 생성2\narr1 = np.zeros(5)\narr2 = np.ones(3)\narr3 = np.full(2, 5)\nprint(arr1)\nprint(arr2)\nprint(arr3)\n```\n\n```{python}\n# 넘파이 배열 생성3\narr1 = np.arange(10)\narr2 = np.arange(3, 6)\narr3 = np.arange(1, 11, 2)\narr4 = np.arange(0, 1, 0.1)\nprint(arr1)\nprint(arr2)\nprint(arr3)\nprint(arr4)\n```\n\n```{python}\n# 넘파이 배열 생성4\narr = np.linspace(0, 1, 5)\nprint(arr)\n```\n\n```{python}\n# 넘파이 배열 생성5\narr1 = np.eye(3)\narr2 = np.eye(3, 4, k=1)\nprint(arr1)\nprint(arr2)\n```\n\n```{python}\n# 넘파이 배열 생성6 : np.identity()는 np.eye()의 특수한 경우\narr = np.identity(4)\nprint(arr)\n```\n\n<br>\n\n### 5.1.2. 넘파이 배열 속성\n|속성|설명|\n|:---:|:------------|\n|.dtype|배열 원소의 자료형|\n|.ndim|배열의 차원 수|\n|.shape|배열의 모양(행, 열)|\n|.size|배열의 전체 원소 개수|\n|.itemsize|원소 하나의 메모리 크기|\n\n<br>\n\n```{python}\n# 넘파이 배열 속성\narr = np.array([[1, 2, 3], [4, 5, 6]])       # 2차원 배열\nprint(arr)\nprint(arr.dtype)\nprint(arr.ndim)\nprint(arr.shape)\nprint(arr.size)\nprint(arr.itemsize)\n```\n\n<br>\n\n## 5.2. 차원과 축\n### 5.2.1. 차원(dimension)\n+ 넘파이 배열의 차원\n  + 관측하고자 하는 데이터의 속성의 수 또는 측정 항목의 수\n  + **스칼라(scalar)** : 0차원 배열, 배열에서 값을 표현하는 가장 기본 단위로 하나의 실수를 저장할 수 있음\n  + **벡터(vector)** : 1차원 배열, 스칼라 여러 개를 나열한 배열\n  + **행렬(matrix)** : 2차원 배열, 1차원 배열을 여러 개 묶은 배열\n  + **텐서(tensor)** : 3차원 이상의 배열, 벡터의 집합\n\n<br>\n\n![](./images/fig5-1.jpg)\n\n<br>\n\n```{python}\narr0 = np.array(3.14)                        # 0차원 배열(스칼라)\narr1 = np.array([3.14])                      # 1차원 배열(벡터)\narr2 = np.array([[3.14]])                    # 2차원 배열(행렬)\narr3 = np.array([[[3.14]]])                  # 3차원 배열(텐서)\n\nprint(arr0.ndim, arr0.shape)\nprint(arr1.ndim, arr1.shape)\nprint(arr2.ndim, arr2.shape)\nprint(arr3.ndim, arr3.shape)\n```\n\n```{python}\n# 1차원 배열(벡터)\narr = np.array([1, 2, 3])\nprint(arr.ndim)\nprint(arr.shape)\n```\n\n```{python}\n# 2차원 배열(행렬)\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr.ndim)\nprint(arr.shape)\n```\n\n```{python}\n# 3차원 배열(텐서)\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[11, 12, 13], [14, 15, 16]]])\nprint(arr.ndim)\nprint(arr.shape)\n```\n\n<br>\n\n### 5.2.2. 축(axis)\n+ 배열에서 데이터를 따라가는 방향\n  + 차원이 있는 데이터에서 어느 방향으로 연산을 적용하는지 축으로 지정\n+ axis 0은 첫 번째 차원으로, 배열의 가장 바깥쪽 차원임\n  + 차원이 늘어날수록 새로운 축이 axis=0가 되며, 기존 축들은 번호가 하나씩 뒤로 밀림\n+ 축 번호는 배열의 차원에 따라 증가하며, 각 축은 shape에서 해당하는 차원의 크기를 나타냄\n  + (예) shape (2, 3, 4) → axis 0: 2(면), axis 1: 3(행), axis 2: 4(열)\n\n<br>\n\n![](./images/fig5-2.png)\n\n<br>\n\n|차원|직관적인 구조|축의 역할|\n|:---:|:------------|:------------|\n|1차원|벡터 → [1, 2, 3, 4]|axis 0: 왼쪽 → 오른쪽|\n|2차원|벡터들이 위아래로 쌓임 → 행렬|axis 0: 위 → 아래(행) <br>axis 1: 왼쪽 → 오른쪽(열)|\n|3차원|행렬들이 앞뒤로 쌓임|axis 0: 앞 → 뒤(면) <br>axis 1: 위 → 아래(행) <br>axis 2: 왼쪽 → 오른쪽(열)|\n\n<br>\n\n<br>\n\n### 5.2.3. 넘파이 배열 메소드\n|함수|설명|\n|:---:|:------------|\n|sum()|합계|\n|mean()|평균|\n|std()|표준편차|\n|min(), max()|최소값, 최대값|\n|cumsum(), cumprod()|누적 합계, 누적 곱|\n|transpose()|축 순서 변경|\n\n<br>\n\n```{python}\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\n# 합계\nprint(np.sum(arr))\nprint(np.sum(arr, axis=0))\nprint(np.sum(arr, axis=1))\n```\n\n```{python}\n# 누적합\nprint(np.cumsum(arr))\nprint(np.cumsum(arr, axis=0))\nprint(np.cumsum(arr, axis=1))\n```\n\n<br>\n\n### 5.2.4. 배열 형태 변환\n|함수|설명|\n|:---:|:------------|\n|reshape()|배열을 데이터 변경없이 새로운 모양으로 변환|\n|flatten()|다차원 배열을 1차원 배열로 복사하여 반환(원본 유지)|\n|ravel()|다차원 배열을 1차원 배열로 반환(가능하면 원본 공유, 더 효율적)|\n\n<br>\n\n```{python}\n# 1차원 배열 → 2차원 배열(3행 2열)\narr = np.array([1, 2, 3, 4, 5, 6])\n\nprint(arr.reshape(3, 2))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n```\n\n```{python}\n# 1차원 배열 → 3차원 배열\narr = np.arange(24)\n\nprint(arr.reshape(2, 3, 4))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n```\n\n```{python}\n# 2차원 배열 → 1차원 배열 (복사본 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.flatten())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n```\n\n```{python}\n# 2차원 배열 → 1차원 배열 (가능하면 뷰 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.ravel())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n```\n\n<br>\n\n### 5.2.5. 축 재배열\n|함수|설명|\n|:---:|:------------|\n|transpose()|배열의 축 순서 변환(2차원 배열의 경우 행/열 전치)|\n|swaqaxes()|지정한 두 축의 순서를 교환|\n\n<br>\n\n```{python}\n# 2차원 배열에서 transpose()\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.transpose())\n```\n\n```{python}\n# 3차원 배열에서 transpose()\narr = np.arange(24).reshape(2, 3, 4)\n\n# 축 순서 바꾸기 : (0, 1, 2) → (1, 0, 2)\nprint(arr.transpose(1, 0, 2))\nprint(arr.transpose(1, 0, 2).shape)\n```\n\n```{python}\n# 3차원 배열에서 axis 0과 axis 2 교환\narr = np.array([\n    [[1, 2], [3, 4]],\n    [[5, 6], [7, 8]]\n])\n\nprint(np.swapaxes(arr, 0, 2))\nprint(np.swapaxes(arr, 0, 2).shape)\n```\n\n<br>\n\n## 5.3. 얕은 복사와 깊은 복사\n+ 얕은 복사(shallow copy)\n  + 데이터의 주소를 복사하여 원본과 메모리 공간을 공유\n  + 원본을 수정하면 복사본이 바뀌며, 반대로 복사본을 수정해도 원본에 영향을 미침\n  + `view()`, `reshape()` (대부분), `ravel()` (대부분)\n\n<br>\n\n+ 깊은 복사(deep copy)\n  + 완전히 새로운 메모리 공간에 데이터의 복사본을 생성\n  + 원본을 수정해도 복사본이 바뀌지 않으며, 반대로 복사본을 수정해도 원본에 영향을 주지 않음\n  + `copy()`, `flatten()`\n\n<br>\n\n```{python}\n# 얕은 복사\narr = np.arange(6)\nprint(arr)\n\ncopy_arr = arr.view()\nprint(copy_arr)\n\ncopy_arr[0] = 10\nprint(arr)\nprint(copy_arr)\n```\n\n```{python}\n# 깊은 복사\narr = np.arange(6)\nprint(arr)\n\ncopy_arr = arr.copy()\nprint(copy_arr)\n\ncopy_arr[0] = 10\nprint(arr)\nprint(copy_arr)\n```\n\n<br>\n\n## 5.4. 인덱싱과 슬라이싱\n+ 인덱싱(indexing)\n  + `[index]`를 사용하여 배열의 특정 위치에 있는 원소에 접근함\n  + 얕은 복사(shallow copy)로 작동 → 원본과 메모리 공간을 공유\n  + **팬시 인덱싱(fancy indexing)**\n    + 배열이나 리스트를 인덱스로 사용하여 원하는 위치의 값들을 한 번에 추출\n    + 복사본을 반환(deep copy) → 원본과 메모리 공간을 공유하지 않음\n  + **불리언 인덱싱(boolean indexing)**\n    + 조건식을 통해 bool형 배열을 생성하여 `True`인 원소만 추출\n    + 복사본을 반환(deep copy) → 원본과 메모리 공간을 공유하지 않음\n\n<br>\n\n+ 슬라이싱(slicing)\n  + `[(start index):(stop index)]`를 사용하여 배열의 일부 원소를 추출함\n  + 얕은 복사(shallow copy)로 작동하며 뷰(view)를 반환 → 원본과 메모리 공간을 공유\n\n<br>\n\n```{python}\n# 1차원 인덱싱과 슬라이싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[0])\nprint(arr[-1])\nprint(arr[1:4])\nprint(arr[::2])\n```\n\n```{python}\n# 슬라이싱은 기본적으로 뷰(view)임\narr = np.array([10, 20, 30, 40, 50])\nprint(arr)\n\nsub_arr = arr[1:4]\nprint(sub_arr)\n\nsub_arr[0] = 100\nprint(arr)\nprint(sub_arr)\n```\n\n```{python}\n# copy() 함수를 이용해서 깊은 복사를 해야 원본이 변하지 않음\narr = np.array([10, 20, 30, 40, 50])\nprint(arr)\n\nsub_arr = arr[1:4].copy()\nprint(sub_arr)\n\nsub_arr[0] = 100\nprint(arr)\nprint(sub_arr)\n```\n\n```{python}\n# 2차원 인덱싱과 슬라이싱\narr = np.array([[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]])\nprint(arr[1, 2])                           # arr[1][2], 리스트에서는 안 됨\nprint(arr[0:2, 1:3])\nprint(arr[0])                              # 첫 번째 행의 모든 열\nprint(arr[:, 1])                           # 모든 행의 두 번째 열\nprint(arr[1:, :2])                         # 두 번째 행부터 끝까지, 처음부터 두 번째 열까지\n```\n\n```{python}\n# 3차원 인덱싱과 슬라이싱\narr = np.arange(24).reshape(2, 3, 4)\n\nprint(arr[1, 2])                           # arr[1][2], 리스트에서는 안 됨\nprint(arr[1, 2, 3])                        # 두 번째 면, 세 번째 행, 네 번째 열\nprint(arr[:, 1, :])                        # 모든 면의 두 번째 행 → shape(2, 4)\n```\n\n```{python}\n# 팬시 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[[0, 3, 4]])\n```\n\n```{python}\n# 불리언 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr > 30)\nprint(arr[arr > 30])\n```\n\n<br>\n\n## 5.5. 넘파이 배열 연산\n+ 벡터화(vectorization)\n  + 반복문을 사용하지 않고 배열 전체에 연산을 적용하는 기능\n  + 동일한 shape을 가진 배열 간에 같은 인덱스에 위치한 원소들끼리(element-wise) 연산을 수행함  \n  + 두 배열의 shape가 다르더라도 브로드캐스팅이 가능한 경우에는 연산이 가능함\n    + 이 경우 내부적으로 브로드캐스팅을 통해 shape를 맞춘 후, 벡터화 연산을 수행함\n   \n<br>\n\n+ 브로드캐스팅(broadcasting)\n  + 차원이 서로 다른 배열 간의 연산을 자동으로 처리해주는 기능\n  + 더 작은 차원인 배열의 shape를 자동으로 확장하여 연산이 가능하도록 함\n  + 브로드캐스팅이 적용되는 조건\n    + 차원이 다르면, 더 작은 배열 앞쪽(왼쪽)에 1을 추가해서 맞춰줌\n    + 차원이 같으면, 각 차원의 크기를 비교하여 두 값이 같거나 한 쪽이 1이면 브로드캐스팅 가능함\n\n<br>\n\n![](./images/fig5-3.png)\n\n<br>\n\n```{python}\n# 벡터화\narr1 = np.array([1, 2, 3])\narr2 = np.array([10, 20, 30])\n\nprint(arr1 + arr2)\nprint(arr1 / arr2)\n```\n\n```{python}\n# 브로드캐스팅1 : 1차원 + 스칼라\narr = np.array([1, 2, 3])\nprint(arr + 10)\n```\n\n```{python}\n# 브로드캐스팅2 : 차원 수가 다른 경우\narr1 = np.array([[1], [2], [3]])           # shape : (3, 1)\narr2 = np.array([10, 20, 30, 40])          # shape : (4,) → (1, 4)로 간주\n\nprint(arr1.shape, arr2.shape)\nprint(arr1 + arr2)                \n```\n\n```{python}\n# 브로드캐스팅3 : 두 배열의 열 크기가 다르므로 브로드캐스팅 불가능\n#arr1 = np.array([[1, 2, 3],\n#                 [4, 5, 6]])               # shape : (2, 3)\n#arr2 = np.array([10, 20, 30, 40])          # shape: (4,) → (1, 4)로 간주\n#\n#print(arr1.shape, arr2.shape)\n#print(arr1 + arr2)\n```\n\n```{python}\n# 브로드캐스팅 : 3차원 + 1차원\narr1 = np.arange(24).reshape(2, 3, 4)      # shape : (2, 3, 4)\narr2 = np.array([10, 20, 30, 40])          # shape : (4,) → (1, 1, 4)로 간주\n\nprint(arr1.shape, arr2.shape)\nprint((arr1 + arr2).shape)                 # shaep : (2, 3, 4)\nprint(arr1 + arr2)\n```\n\n","srcMarkdownNoYaml":"\n\n<h1>5. NumPy</h1>\n<br>\n\n## 5.1. 넘파이 배열\n### 5.1.1. 넘파이 배열 생성\n+ NumPy\n  + Numerical Python의 약자로, C언어로 구현된 Python 라이브러리\n  + 고성능 수치 계산, 대규모 다차원 배열 및 행렬 연산에 최적화\n\n<br>\n\n+ 넘파이 배열(ndarray)\n  + 리스트처럼 데이터를 모아 저장하는 자료구조\n  + **모든 원소가 동일한 자료형**으로 저장(효율적인 메모리 관리 및 빠른 연산)\n  + 대규모 데이터 처리에 유리함\n  + 반복문 없이 배열 간 연산이 가능한 브로드캐스팅 및 벡터화 연산 지원\n  + 다양한 수학 함수, 선형대수, 난수 생성 기능 제공\n\n<br>\n\n|함수|설명|\n|:---:|:------------|\n|np.array()|리스트, 튜플 등으로부터 배열 생성|\n|np.zeros()|모든 값이 0인 배열 생성|\n|np.ones()|모든 값이 1인 배열 생성|\n|np.full()|지정한 값으로 이루어진 배열 생성|\n|np.arange()|범위를 지정하여 연속적인 값의 배열 생성(`range()`와 비슷)|\n|np.linspace()|시작과 끝을 기준으로, 지정한 개수만큼 일정 간격의 값으로 배열 생성|\n|np.eye()|행과 열의 크기를 지정할 수 있는 단위행렬(2차원 배열) 생성|\n|np.identity()|정방 단위행렬(2차원 배열) 생성|\n\n<br>\n\n```{python}\nimport numpy as np\n```\n\n```{python}\n# 넘파이 배열 생성1\narr1 = np.array([1, 2, 3])\narr2 = np.array((6, 7, 8, 9))\nprint(arr1)\nprint(arr2)\n```\n\n```{python}\n# 넘파이 배열 생성2\narr1 = np.zeros(5)\narr2 = np.ones(3)\narr3 = np.full(2, 5)\nprint(arr1)\nprint(arr2)\nprint(arr3)\n```\n\n```{python}\n# 넘파이 배열 생성3\narr1 = np.arange(10)\narr2 = np.arange(3, 6)\narr3 = np.arange(1, 11, 2)\narr4 = np.arange(0, 1, 0.1)\nprint(arr1)\nprint(arr2)\nprint(arr3)\nprint(arr4)\n```\n\n```{python}\n# 넘파이 배열 생성4\narr = np.linspace(0, 1, 5)\nprint(arr)\n```\n\n```{python}\n# 넘파이 배열 생성5\narr1 = np.eye(3)\narr2 = np.eye(3, 4, k=1)\nprint(arr1)\nprint(arr2)\n```\n\n```{python}\n# 넘파이 배열 생성6 : np.identity()는 np.eye()의 특수한 경우\narr = np.identity(4)\nprint(arr)\n```\n\n<br>\n\n### 5.1.2. 넘파이 배열 속성\n|속성|설명|\n|:---:|:------------|\n|.dtype|배열 원소의 자료형|\n|.ndim|배열의 차원 수|\n|.shape|배열의 모양(행, 열)|\n|.size|배열의 전체 원소 개수|\n|.itemsize|원소 하나의 메모리 크기|\n\n<br>\n\n```{python}\n# 넘파이 배열 속성\narr = np.array([[1, 2, 3], [4, 5, 6]])       # 2차원 배열\nprint(arr)\nprint(arr.dtype)\nprint(arr.ndim)\nprint(arr.shape)\nprint(arr.size)\nprint(arr.itemsize)\n```\n\n<br>\n\n## 5.2. 차원과 축\n### 5.2.1. 차원(dimension)\n+ 넘파이 배열의 차원\n  + 관측하고자 하는 데이터의 속성의 수 또는 측정 항목의 수\n  + **스칼라(scalar)** : 0차원 배열, 배열에서 값을 표현하는 가장 기본 단위로 하나의 실수를 저장할 수 있음\n  + **벡터(vector)** : 1차원 배열, 스칼라 여러 개를 나열한 배열\n  + **행렬(matrix)** : 2차원 배열, 1차원 배열을 여러 개 묶은 배열\n  + **텐서(tensor)** : 3차원 이상의 배열, 벡터의 집합\n\n<br>\n\n![](./images/fig5-1.jpg)\n\n<br>\n\n```{python}\narr0 = np.array(3.14)                        # 0차원 배열(스칼라)\narr1 = np.array([3.14])                      # 1차원 배열(벡터)\narr2 = np.array([[3.14]])                    # 2차원 배열(행렬)\narr3 = np.array([[[3.14]]])                  # 3차원 배열(텐서)\n\nprint(arr0.ndim, arr0.shape)\nprint(arr1.ndim, arr1.shape)\nprint(arr2.ndim, arr2.shape)\nprint(arr3.ndim, arr3.shape)\n```\n\n```{python}\n# 1차원 배열(벡터)\narr = np.array([1, 2, 3])\nprint(arr.ndim)\nprint(arr.shape)\n```\n\n```{python}\n# 2차원 배열(행렬)\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr.ndim)\nprint(arr.shape)\n```\n\n```{python}\n# 3차원 배열(텐서)\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[11, 12, 13], [14, 15, 16]]])\nprint(arr.ndim)\nprint(arr.shape)\n```\n\n<br>\n\n### 5.2.2. 축(axis)\n+ 배열에서 데이터를 따라가는 방향\n  + 차원이 있는 데이터에서 어느 방향으로 연산을 적용하는지 축으로 지정\n+ axis 0은 첫 번째 차원으로, 배열의 가장 바깥쪽 차원임\n  + 차원이 늘어날수록 새로운 축이 axis=0가 되며, 기존 축들은 번호가 하나씩 뒤로 밀림\n+ 축 번호는 배열의 차원에 따라 증가하며, 각 축은 shape에서 해당하는 차원의 크기를 나타냄\n  + (예) shape (2, 3, 4) → axis 0: 2(면), axis 1: 3(행), axis 2: 4(열)\n\n<br>\n\n![](./images/fig5-2.png)\n\n<br>\n\n|차원|직관적인 구조|축의 역할|\n|:---:|:------------|:------------|\n|1차원|벡터 → [1, 2, 3, 4]|axis 0: 왼쪽 → 오른쪽|\n|2차원|벡터들이 위아래로 쌓임 → 행렬|axis 0: 위 → 아래(행) <br>axis 1: 왼쪽 → 오른쪽(열)|\n|3차원|행렬들이 앞뒤로 쌓임|axis 0: 앞 → 뒤(면) <br>axis 1: 위 → 아래(행) <br>axis 2: 왼쪽 → 오른쪽(열)|\n\n<br>\n\n<br>\n\n### 5.2.3. 넘파이 배열 메소드\n|함수|설명|\n|:---:|:------------|\n|sum()|합계|\n|mean()|평균|\n|std()|표준편차|\n|min(), max()|최소값, 최대값|\n|cumsum(), cumprod()|누적 합계, 누적 곱|\n|transpose()|축 순서 변경|\n\n<br>\n\n```{python}\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\n# 합계\nprint(np.sum(arr))\nprint(np.sum(arr, axis=0))\nprint(np.sum(arr, axis=1))\n```\n\n```{python}\n# 누적합\nprint(np.cumsum(arr))\nprint(np.cumsum(arr, axis=0))\nprint(np.cumsum(arr, axis=1))\n```\n\n<br>\n\n### 5.2.4. 배열 형태 변환\n|함수|설명|\n|:---:|:------------|\n|reshape()|배열을 데이터 변경없이 새로운 모양으로 변환|\n|flatten()|다차원 배열을 1차원 배열로 복사하여 반환(원본 유지)|\n|ravel()|다차원 배열을 1차원 배열로 반환(가능하면 원본 공유, 더 효율적)|\n\n<br>\n\n```{python}\n# 1차원 배열 → 2차원 배열(3행 2열)\narr = np.array([1, 2, 3, 4, 5, 6])\n\nprint(arr.reshape(3, 2))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n```\n\n```{python}\n# 1차원 배열 → 3차원 배열\narr = np.arange(24)\n\nprint(arr.reshape(2, 3, 4))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n```\n\n```{python}\n# 2차원 배열 → 1차원 배열 (복사본 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.flatten())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n```\n\n```{python}\n# 2차원 배열 → 1차원 배열 (가능하면 뷰 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.ravel())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n```\n\n<br>\n\n### 5.2.5. 축 재배열\n|함수|설명|\n|:---:|:------------|\n|transpose()|배열의 축 순서 변환(2차원 배열의 경우 행/열 전치)|\n|swaqaxes()|지정한 두 축의 순서를 교환|\n\n<br>\n\n```{python}\n# 2차원 배열에서 transpose()\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.transpose())\n```\n\n```{python}\n# 3차원 배열에서 transpose()\narr = np.arange(24).reshape(2, 3, 4)\n\n# 축 순서 바꾸기 : (0, 1, 2) → (1, 0, 2)\nprint(arr.transpose(1, 0, 2))\nprint(arr.transpose(1, 0, 2).shape)\n```\n\n```{python}\n# 3차원 배열에서 axis 0과 axis 2 교환\narr = np.array([\n    [[1, 2], [3, 4]],\n    [[5, 6], [7, 8]]\n])\n\nprint(np.swapaxes(arr, 0, 2))\nprint(np.swapaxes(arr, 0, 2).shape)\n```\n\n<br>\n\n## 5.3. 얕은 복사와 깊은 복사\n+ 얕은 복사(shallow copy)\n  + 데이터의 주소를 복사하여 원본과 메모리 공간을 공유\n  + 원본을 수정하면 복사본이 바뀌며, 반대로 복사본을 수정해도 원본에 영향을 미침\n  + `view()`, `reshape()` (대부분), `ravel()` (대부분)\n\n<br>\n\n+ 깊은 복사(deep copy)\n  + 완전히 새로운 메모리 공간에 데이터의 복사본을 생성\n  + 원본을 수정해도 복사본이 바뀌지 않으며, 반대로 복사본을 수정해도 원본에 영향을 주지 않음\n  + `copy()`, `flatten()`\n\n<br>\n\n```{python}\n# 얕은 복사\narr = np.arange(6)\nprint(arr)\n\ncopy_arr = arr.view()\nprint(copy_arr)\n\ncopy_arr[0] = 10\nprint(arr)\nprint(copy_arr)\n```\n\n```{python}\n# 깊은 복사\narr = np.arange(6)\nprint(arr)\n\ncopy_arr = arr.copy()\nprint(copy_arr)\n\ncopy_arr[0] = 10\nprint(arr)\nprint(copy_arr)\n```\n\n<br>\n\n## 5.4. 인덱싱과 슬라이싱\n+ 인덱싱(indexing)\n  + `[index]`를 사용하여 배열의 특정 위치에 있는 원소에 접근함\n  + 얕은 복사(shallow copy)로 작동 → 원본과 메모리 공간을 공유\n  + **팬시 인덱싱(fancy indexing)**\n    + 배열이나 리스트를 인덱스로 사용하여 원하는 위치의 값들을 한 번에 추출\n    + 복사본을 반환(deep copy) → 원본과 메모리 공간을 공유하지 않음\n  + **불리언 인덱싱(boolean indexing)**\n    + 조건식을 통해 bool형 배열을 생성하여 `True`인 원소만 추출\n    + 복사본을 반환(deep copy) → 원본과 메모리 공간을 공유하지 않음\n\n<br>\n\n+ 슬라이싱(slicing)\n  + `[(start index):(stop index)]`를 사용하여 배열의 일부 원소를 추출함\n  + 얕은 복사(shallow copy)로 작동하며 뷰(view)를 반환 → 원본과 메모리 공간을 공유\n\n<br>\n\n```{python}\n# 1차원 인덱싱과 슬라이싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[0])\nprint(arr[-1])\nprint(arr[1:4])\nprint(arr[::2])\n```\n\n```{python}\n# 슬라이싱은 기본적으로 뷰(view)임\narr = np.array([10, 20, 30, 40, 50])\nprint(arr)\n\nsub_arr = arr[1:4]\nprint(sub_arr)\n\nsub_arr[0] = 100\nprint(arr)\nprint(sub_arr)\n```\n\n```{python}\n# copy() 함수를 이용해서 깊은 복사를 해야 원본이 변하지 않음\narr = np.array([10, 20, 30, 40, 50])\nprint(arr)\n\nsub_arr = arr[1:4].copy()\nprint(sub_arr)\n\nsub_arr[0] = 100\nprint(arr)\nprint(sub_arr)\n```\n\n```{python}\n# 2차원 인덱싱과 슬라이싱\narr = np.array([[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]])\nprint(arr[1, 2])                           # arr[1][2], 리스트에서는 안 됨\nprint(arr[0:2, 1:3])\nprint(arr[0])                              # 첫 번째 행의 모든 열\nprint(arr[:, 1])                           # 모든 행의 두 번째 열\nprint(arr[1:, :2])                         # 두 번째 행부터 끝까지, 처음부터 두 번째 열까지\n```\n\n```{python}\n# 3차원 인덱싱과 슬라이싱\narr = np.arange(24).reshape(2, 3, 4)\n\nprint(arr[1, 2])                           # arr[1][2], 리스트에서는 안 됨\nprint(arr[1, 2, 3])                        # 두 번째 면, 세 번째 행, 네 번째 열\nprint(arr[:, 1, :])                        # 모든 면의 두 번째 행 → shape(2, 4)\n```\n\n```{python}\n# 팬시 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[[0, 3, 4]])\n```\n\n```{python}\n# 불리언 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr > 30)\nprint(arr[arr > 30])\n```\n\n<br>\n\n## 5.5. 넘파이 배열 연산\n+ 벡터화(vectorization)\n  + 반복문을 사용하지 않고 배열 전체에 연산을 적용하는 기능\n  + 동일한 shape을 가진 배열 간에 같은 인덱스에 위치한 원소들끼리(element-wise) 연산을 수행함  \n  + 두 배열의 shape가 다르더라도 브로드캐스팅이 가능한 경우에는 연산이 가능함\n    + 이 경우 내부적으로 브로드캐스팅을 통해 shape를 맞춘 후, 벡터화 연산을 수행함\n   \n<br>\n\n+ 브로드캐스팅(broadcasting)\n  + 차원이 서로 다른 배열 간의 연산을 자동으로 처리해주는 기능\n  + 더 작은 차원인 배열의 shape를 자동으로 확장하여 연산이 가능하도록 함\n  + 브로드캐스팅이 적용되는 조건\n    + 차원이 다르면, 더 작은 배열 앞쪽(왼쪽)에 1을 추가해서 맞춰줌\n    + 차원이 같으면, 각 차원의 크기를 비교하여 두 값이 같거나 한 쪽이 1이면 브로드캐스팅 가능함\n\n<br>\n\n![](./images/fig5-3.png)\n\n<br>\n\n```{python}\n# 벡터화\narr1 = np.array([1, 2, 3])\narr2 = np.array([10, 20, 30])\n\nprint(arr1 + arr2)\nprint(arr1 / arr2)\n```\n\n```{python}\n# 브로드캐스팅1 : 1차원 + 스칼라\narr = np.array([1, 2, 3])\nprint(arr + 10)\n```\n\n```{python}\n# 브로드캐스팅2 : 차원 수가 다른 경우\narr1 = np.array([[1], [2], [3]])           # shape : (3, 1)\narr2 = np.array([10, 20, 30, 40])          # shape : (4,) → (1, 4)로 간주\n\nprint(arr1.shape, arr2.shape)\nprint(arr1 + arr2)                \n```\n\n```{python}\n# 브로드캐스팅3 : 두 배열의 열 크기가 다르므로 브로드캐스팅 불가능\n#arr1 = np.array([[1, 2, 3],\n#                 [4, 5, 6]])               # shape : (2, 3)\n#arr2 = np.array([10, 20, 30, 40])          # shape: (4,) → (1, 4)로 간주\n#\n#print(arr1.shape, arr2.shape)\n#print(arr1 + arr2)\n```\n\n```{python}\n# 브로드캐스팅 : 3차원 + 1차원\narr1 = np.arange(24).reshape(2, 3, 4)      # shape : (2, 3, 4)\narr2 = np.array([10, 20, 30, 40])          # shape : (4,) → (1, 1, 4)로 간주\n\nprint(arr1.shape, arr2.shape)\nprint((arr1 + arr2).shape)                 # shaep : (2, 3, 4)\nprint(arr1 + arr2)\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"5_numpy.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.42","theme":["simplex"],"toc-location":"right","toc-expand":true,"jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}