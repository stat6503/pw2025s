{
  "hash": "f8fdf930012bc3148b8ea3fe397bca8e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\njupyter: python3\n---\n\n\n\n\n<h1>5. NumPy</h1>\n<br>\n\n## 5.1. 넘파이 배열\n### 5.1.1. 넘파이 배열 생성\n+ NumPy\n  + Numerical Python의 약자로, C언어로 구현된 Python 라이브러리\n  + 고성능 수치 계산, 대규모 다차원 배열 및 행렬 연산에 최적화\n\n<br>\n\n+ 넘파이 배열(ndarray)\n  + 리스트처럼 데이터를 모아 저장하는 자료구조\n  + **모든 원소가 동일한 자료형**으로 저장(효율적인 메모리 관리 및 빠른 연산)\n  + 대규모 데이터 처리에 유리함\n  + 반복문 없이 배열 간 연산이 가능한 브로드캐스팅 및 벡터화 연산 지원\n  + 다양한 수학 함수, 선형대수, 난수 생성 기능 제공\n\n<br>\n\n|함수|설명|\n|:---:|:------------|\n|np.array()|리스트, 튜플 등으로부터 배열 생성|\n|np.zeros()|모든 값이 0인 배열 생성|\n|np.ones()|모든 값이 1인 배열 생성|\n|np.full()|지정한 값으로 이루어진 배열 생성|\n|np.arange()|범위를 지정하여 연속적인 값의 배열 생성(`range()`와 비슷)|\n|np.linspace()|시작과 끝을 기준으로, 지정한 개수만큼 일정 간격의 값으로 배열 생성|\n|np.eye()|행과 열의 크기를 지정할 수 있는 단위행렬(2차원 배열) 생성|\n|np.identity()|정방 단위행렬(2차원 배열) 생성|\n\n<br>\n\n::: {#26c50659 .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n```\n:::\n\n\n::: {#33fd3534 .cell execution_count=2}\n``` {.python .cell-code}\n# 넘파이 배열 생성1\narr1 = np.array([1, 2, 3])\narr2 = np.array((6, 7, 8, 9))\nprint(arr1)\nprint(arr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3]\n[6 7 8 9]\n```\n:::\n:::\n\n\n::: {#3707a4ed .cell execution_count=3}\n``` {.python .cell-code}\n# 넘파이 배열 생성2\narr1 = np.zeros(5)\narr2 = np.ones(3)\narr3 = np.full(2, 5)\nprint(arr1)\nprint(arr2)\nprint(arr3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0. 0. 0. 0. 0.]\n[1. 1. 1.]\n[5 5]\n```\n:::\n:::\n\n\n::: {#10277e87 .cell execution_count=4}\n``` {.python .cell-code}\n# 넘파이 배열 생성3\narr1 = np.arange(10)\narr2 = np.arange(3, 6)\narr3 = np.arange(1, 11, 2)\narr4 = np.arange(0, 1, 0.1)\nprint(arr1)\nprint(arr2)\nprint(arr3)\nprint(arr4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3 4 5 6 7 8 9]\n[3 4 5]\n[1 3 5 7 9]\n[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]\n```\n:::\n:::\n\n\n::: {#1d316acd .cell execution_count=5}\n``` {.python .cell-code}\n# 넘파이 배열 생성4\narr = np.linspace(0, 1, 5)\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.   0.25 0.5  0.75 1.  ]\n```\n:::\n:::\n\n\n::: {#eb853a64 .cell execution_count=6}\n``` {.python .cell-code}\n# 넘파이 배열 생성5\narr1 = np.eye(3)\narr2 = np.eye(3, 4, k=1)\nprint(arr1)\nprint(arr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n[[0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n```\n:::\n:::\n\n\n::: {#503c971f .cell execution_count=7}\n``` {.python .cell-code}\n# 넘파이 배열 생성6 : np.identity()는 np.eye()의 특수한 경우\narr = np.identity(4)\nprint(arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n```\n:::\n:::\n\n\n<br>\n\n### 5.1.2. 넘파이 배열 속성\n|속성|설명|\n|:---:|:------------|\n|.dtype|배열 원소의 자료형|\n|.ndim|배열의 차원 수|\n|.shape|배열의 모양(행, 열)|\n|.size|배열의 전체 원소 개수|\n|.itemsize|원소 하나의 메모리 크기|\n\n<br>\n\n::: {#6adb8f73 .cell execution_count=8}\n``` {.python .cell-code}\n# 넘파이 배열 속성\narr = np.array([[1, 2, 3], [4, 5, 6]])       # 2차원 배열\nprint(arr)\nprint(arr.dtype)\nprint(arr.ndim)\nprint(arr.shape)\nprint(arr.size)\nprint(arr.itemsize)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2 3]\n [4 5 6]]\nint32\n2\n(2, 3)\n6\n4\n```\n:::\n:::\n\n\n<br>\n\n## 5.2. 차원과 축\n### 5.2.1. 차원(dimension)\n+ 넘파이 배열의 차원\n  + 관측하고자 하는 데이터의 속성의 수 또는 측정 항목의 수\n  + **스칼라(scalar)** : 0차원 배열, 배열에서 값을 표현하는 가장 기본 단위로 하나의 실수를 저장할 수 있음\n  + **벡터(vector)** : 1차원 배열, 스칼라 여러 개를 나열한 배열\n  + **행렬(matrix)** : 2차원 배열, 1차원 배열을 여러 개 묶은 배열\n  + **텐서(tensor)** : 3차원 이상의 배열, 벡터의 집합\n\n<br>\n\n![](./images/fig5-1.jpg)\n\n<br>\n\n::: {#5b31fee0 .cell execution_count=9}\n``` {.python .cell-code}\narr0 = np.array(3.14)                        # 0차원 배열(스칼라)\narr1 = np.array([3.14])                      # 1차원 배열(벡터)\narr2 = np.array([[3.14]])                    # 2차원 배열(행렬)\narr3 = np.array([[[3.14]]])                  # 3차원 배열(텐서)\n\nprint(arr0.ndim, arr0.shape)\nprint(arr1.ndim, arr1.shape)\nprint(arr2.ndim, arr2.shape)\nprint(arr3.ndim, arr3.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0 ()\n1 (1,)\n2 (1, 1)\n3 (1, 1, 1)\n```\n:::\n:::\n\n\n::: {#39ca3dc4 .cell execution_count=10}\n``` {.python .cell-code}\n# 1차원 배열(벡터)\narr = np.array([1, 2, 3])\nprint(arr.ndim)\nprint(arr.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1\n(3,)\n```\n:::\n:::\n\n\n::: {#a3e5de1d .cell execution_count=11}\n``` {.python .cell-code}\n# 2차원 배열(행렬)\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr.ndim)\nprint(arr.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2\n(2, 3)\n```\n:::\n:::\n\n\n::: {#b8c5aea8 .cell execution_count=12}\n``` {.python .cell-code}\n# 3차원 배열(텐서)\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[11, 12, 13], [14, 15, 16]]])\nprint(arr.ndim)\nprint(arr.shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3\n(2, 2, 3)\n```\n:::\n:::\n\n\n<br>\n\n### 5.2.2. 축(axis)\n+ 배열에서 데이터를 따라가는 방향\n  + 차원이 있는 데이터에서 어느 방향으로 연산을 적용하는지 축으로 지정\n+ axis 0은 첫 번째 차원으로, 배열의 가장 바깥쪽 차원임\n  + 차원이 늘어날수록 새로운 축이 axis=0가 되며, 기존 축들은 번호가 하나씩 뒤로 밀림\n+ 축 번호는 배열의 차원에 따라 증가하며, 각 축은 shape에서 해당하는 차원의 크기를 나타냄\n  + (예) shape (2, 3, 4) → axis 0: 2(면), axis 1: 3(행), axis 2: 4(열)\n\n<br>\n\n![](./images/fig5-2.png)\n\n<br>\n\n|차원|직관적인 구조|축의 역할|\n|:---:|:------------|:------------|\n|1차원|벡터 → [1, 2, 3, 4]|axis 0: 왼쪽 → 오른쪽|\n|2차원|벡터들이 위아래로 쌓임 → 행렬|axis 0: 위 → 아래(행) <br>axis 1: 왼쪽 → 오른쪽(열)|\n|3차원|행렬들이 앞뒤로 쌓임|axis 0: 앞 → 뒤(면) <br>axis 1: 위 → 아래(행) <br>axis 2: 왼쪽 → 오른쪽(열)|\n\n<br>\n\n<br>\n\n### 5.2.3. 넘파이 배열 메소드\n|함수|설명|\n|:---:|:------------|\n|sum()|합계|\n|mean()|평균|\n|std()|표준편차|\n|min(), max()|최소값, 최대값|\n|cumsum(), cumprod()|누적 합계, 누적 곱|\n|transpose()|축 순서 변경|\n\n<br>\n\n::: {#17a2fe84 .cell execution_count=13}\n``` {.python .cell-code}\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\n# 합계\nprint(np.sum(arr))\nprint(np.sum(arr, axis=0))\nprint(np.sum(arr, axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n21\n[5 7 9]\n[ 6 15]\n```\n:::\n:::\n\n\n::: {#d374dd9e .cell execution_count=14}\n``` {.python .cell-code}\n# 누적합\nprint(np.cumsum(arr))\nprint(np.cumsum(arr, axis=0))\nprint(np.cumsum(arr, axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[ 1  3  6 10 15 21]\n[[1 2 3]\n [5 7 9]]\n[[ 1  3  6]\n [ 4  9 15]]\n```\n:::\n:::\n\n\n<br>\n\n### 5.2.4. 배열 형태 변환\n|함수|설명|\n|:---:|:------------|\n|reshape()|배열을 데이터 변경없이 새로운 모양으로 변환|\n|flatten()|다차원 배열을 1차원 배열로 복사하여 반환(원본 유지)|\n|ravel()|다차원 배열을 1차원 배열로 반환(가능하면 원본 공유, 더 효율적)|\n\n<br>\n\n::: {#81ca9702 .cell execution_count=15}\n``` {.python .cell-code}\n# 1차원 배열 → 2차원 배열(3행 2열)\narr = np.array([1, 2, 3, 4, 5, 6])\n\nprint(arr.reshape(3, 2))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 2]\n [3 4]\n [5 6]]\n[1 2 3 4 5 6]\n```\n:::\n:::\n\n\n::: {#284ab4cf .cell execution_count=16}\n``` {.python .cell-code}\n# 1차원 배열 → 3차원 배열\narr = np.arange(24)\n\nprint(arr.reshape(2, 3, 4))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[[ 0  1  2  3]\n  [ 4  5  6  7]\n  [ 8  9 10 11]]\n\n [[12 13 14 15]\n  [16 17 18 19]\n  [20 21 22 23]]]\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]\n```\n:::\n:::\n\n\n::: {#ca548e38 .cell execution_count=17}\n``` {.python .cell-code}\n# 2차원 배열 → 1차원 배열 (복사본 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.flatten())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n```\n:::\n:::\n\n\n::: {#92a0b2b9 .cell execution_count=18}\n``` {.python .cell-code}\n# 2차원 배열 → 1차원 배열 (가능하면 뷰 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.ravel())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n```\n:::\n:::\n\n\n<br>\n\n### 5.2.5. 축 재배열\n|함수|설명|\n|:---:|:------------|\n|transpose()|배열의 축 순서 변환(2차원 배열의 경우 행/열 전치)|\n|swaqaxes()|지정한 두 축의 순서를 교환|\n\n<br>\n\n::: {#17d8534e .cell execution_count=19}\n``` {.python .cell-code}\n# 2차원 배열에서 transpose()\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.transpose())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1 4]\n [2 5]\n [3 6]]\n```\n:::\n:::\n\n\n::: {#6e577fc3 .cell execution_count=20}\n``` {.python .cell-code}\n# 3차원 배열에서 transpose()\narr = np.arange(24).reshape(2, 3, 4)\n\n# 축 순서 바꾸기 : (0, 1, 2) → (1, 0, 2)\nprint(arr.transpose(1, 0, 2))\nprint(arr.transpose(1, 0, 2).shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[[ 0  1  2  3]\n  [12 13 14 15]]\n\n [[ 4  5  6  7]\n  [16 17 18 19]]\n\n [[ 8  9 10 11]\n  [20 21 22 23]]]\n(3, 2, 4)\n```\n:::\n:::\n\n\n::: {#019d2d8e .cell execution_count=21}\n``` {.python .cell-code}\n# 3차원 배열에서 axis 0과 axis 2 교환\narr = np.array([\n    [[1, 2], [3, 4]],\n    [[5, 6], [7, 8]]\n])\n\nprint(np.swapaxes(arr, 0, 2))\nprint(np.swapaxes(arr, 0, 2).shape)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[[1 5]\n  [3 7]]\n\n [[2 6]\n  [4 8]]]\n(2, 2, 2)\n```\n:::\n:::\n\n\n<br>\n\n## 5.3. 얕은 복사와 깊은 복사\n+ 얕은 복사(shallow copy)\n  + 데이터의 주소를 복사하여 원본과 메모리 공간을 공유\n  + 원본을 수정하면 복사본이 바뀌며, 반대로 복사본을 수정해도 원본에 영향을 미침\n  + `view()`, `reshape()` (대부분), `ravel()` (대부분)\n\n<br>\n\n+ 깊은 복사(deep copy)\n  + 완전히 새로운 메모리 공간에 데이터의 복사본을 생성\n  + 원본을 수정해도 복사본이 바뀌지 않으며, 반대로 복사본을 수정해도 원본에 영향을 주지 않음\n  + `copy()`, `flatten()`\n\n<br>\n\n::: {#be6a35d5 .cell execution_count=22}\n``` {.python .cell-code}\n# 얕은 복사\narr = np.arange(6)\nprint(arr)\n\ncopy_arr = arr.view()\nprint(copy_arr)\n\ncopy_arr[0] = 10\nprint(arr)\nprint(copy_arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n[10  1  2  3  4  5]\n[10  1  2  3  4  5]\n```\n:::\n:::\n\n\n::: {#0f81f4e9 .cell execution_count=23}\n``` {.python .cell-code}\n# 깊은 복사\narr = np.arange(6)\nprint(arr)\n\ncopy_arr = arr.copy()\nprint(copy_arr)\n\ncopy_arr[0] = 10\nprint(arr)\nprint(copy_arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n[10  1  2  3  4  5]\n```\n:::\n:::\n\n\n<br>\n\n## 5.4. 인덱싱과 슬라이싱\n+ 인덱싱(indexing)\n  + `[index]`를 사용하여 배열의 특정 위치에 있는 원소에 접근함\n  + 얕은 복사(shallow copy)로 작동 → 원본과 메모리 공간을 공유\n  + **팬시 인덱싱(fancy indexing)**\n    + 배열이나 리스트를 인덱스로 사용하여 원하는 위치의 값들을 한 번에 추출\n    + 복사본을 반환(deep copy) → 원본과 메모리 공간을 공유하지 않음\n  + **불리언 인덱싱(boolean indexing)**\n    + 조건식을 통해 bool형 배열을 생성하여 `True`인 원소만 추출\n    + 복사본을 반환(deep copy) → 원본과 메모리 공간을 공유하지 않음\n\n<br>\n\n+ 슬라이싱(slicing)\n  + `[(start index):(stop index)]`를 사용하여 배열의 일부 원소를 추출함\n  + 얕은 복사(shallow copy)로 작동하며 뷰(view)를 반환 → 원본과 메모리 공간을 공유\n\n<br>\n\n::: {#75c7c6cf .cell execution_count=24}\n``` {.python .cell-code}\n# 1차원 인덱싱과 슬라이싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[0])\nprint(arr[-1])\nprint(arr[1:4])\nprint(arr[::2])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10\n50\n[20 30 40]\n[10 30 50]\n```\n:::\n:::\n\n\n::: {#97f204f0 .cell execution_count=25}\n``` {.python .cell-code}\n# 슬라이싱은 기본적으로 뷰(view)임\narr = np.array([10, 20, 30, 40, 50])\nprint(arr)\n\nsub_arr = arr[1:4]\nprint(sub_arr)\n\nsub_arr[0] = 100\nprint(arr)\nprint(sub_arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10 20 30 40 50]\n[20 30 40]\n[ 10 100  30  40  50]\n[100  30  40]\n```\n:::\n:::\n\n\n::: {#1fc1b38a .cell execution_count=26}\n``` {.python .cell-code}\n# copy() 함수를 이용해서 깊은 복사를 해야 원본이 변하지 않음\narr = np.array([10, 20, 30, 40, 50])\nprint(arr)\n\nsub_arr = arr[1:4].copy()\nprint(sub_arr)\n\nsub_arr[0] = 100\nprint(arr)\nprint(sub_arr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10 20 30 40 50]\n[20 30 40]\n[10 20 30 40 50]\n[100  30  40]\n```\n:::\n:::\n\n\n::: {#272a44e9 .cell execution_count=27}\n``` {.python .cell-code}\n# 2차원 인덱싱과 슬라이싱\narr = np.array([[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]])\nprint(arr[1, 2])                           # arr[1][2], 리스트에서는 안 됨\nprint(arr[0:2, 1:3])\nprint(arr[0])                              # 첫 번째 행의 모든 열\nprint(arr[:, 1])                           # 모든 행의 두 번째 열\nprint(arr[1:, :2])                         # 두 번째 행부터 끝까지, 처음부터 두 번째 열까지\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n6\n[[2 3]\n [5 6]]\n[1 2 3]\n[2 5 8]\n[[4 5]\n [7 8]]\n```\n:::\n:::\n\n\n::: {#cb49293c .cell execution_count=28}\n``` {.python .cell-code}\n# 3차원 인덱싱과 슬라이싱\narr = np.arange(24).reshape(2, 3, 4)\n\nprint(arr[1, 2])                           # arr[1][2], 리스트에서는 안 됨\nprint(arr[1, 2, 3])                        # 두 번째 면, 세 번째 행, 네 번째 열\nprint(arr[:, 1, :])                        # 모든 면의 두 번째 행 → shape(2, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[20 21 22 23]\n23\n[[ 4  5  6  7]\n [16 17 18 19]]\n```\n:::\n:::\n\n\n::: {#1608e5fd .cell execution_count=29}\n``` {.python .cell-code}\n# 팬시 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[[0, 3, 4]])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[10 40 50]\n```\n:::\n:::\n\n\n::: {#7bd2dc04 .cell execution_count=30}\n``` {.python .cell-code}\n# 불리언 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr > 30)\nprint(arr[arr > 30])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[False False False  True  True]\n[40 50]\n```\n:::\n:::\n\n\n<br>\n\n## 5.5. 넘파이 배열 연산\n+ 벡터화(vectorization)\n  + 반복문을 사용하지 않고 배열 전체에 연산을 적용하는 기능\n  + 동일한 shape을 가진 배열 간에 같은 인덱스에 위치한 원소들끼리(element-wise) 연산을 수행함  \n  + 두 배열의 shape가 다르더라도 브로드캐스팅이 가능한 경우에는 연산이 가능함\n    + 이 경우 내부적으로 브로드캐스팅을 통해 shape를 맞춘 후, 벡터화 연산을 수행함\n   \n<br>\n\n+ 브로드캐스팅(broadcasting)\n  + 차원이 서로 다른 배열 간의 연산을 자동으로 처리해주는 기능\n  + 더 작은 차원인 배열의 shape를 자동으로 확장하여 연산이 가능하도록 함\n  + 브로드캐스팅이 적용되는 조건\n    + 차원이 다르면, 더 작은 배열 앞쪽(왼쪽)에 1을 추가해서 맞춰줌\n    + 차원이 같으면, 각 차원의 크기를 비교하여 두 값이 같거나 한 쪽이 1이면 브로드캐스팅 가능함\n\n<br>\n\n![](./images/fig5-3.png)\n\n<br>\n\n::: {#eb650bf8 .cell execution_count=31}\n``` {.python .cell-code}\n# 벡터화\narr1 = np.array([1, 2, 3])\narr2 = np.array([10, 20, 30])\n\nprint(arr1 + arr2)\nprint(arr1 / arr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[11 22 33]\n[0.1 0.1 0.1]\n```\n:::\n:::\n\n\n::: {#b1e9f24f .cell execution_count=32}\n``` {.python .cell-code}\n# 브로드캐스팅1 : 1차원 + 스칼라\narr = np.array([1, 2, 3])\nprint(arr + 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[11 12 13]\n```\n:::\n:::\n\n\n::: {#20af440a .cell execution_count=33}\n``` {.python .cell-code}\n# 브로드캐스팅2 : 차원 수가 다른 경우\narr1 = np.array([[1], [2], [3]])           # shape : (3, 1)\narr2 = np.array([10, 20, 30, 40])          # shape : (4,) → (1, 4)로 간주\n\nprint(arr1.shape, arr2.shape)\nprint(arr1 + arr2)                \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(3, 1) (4,)\n[[11 21 31 41]\n [12 22 32 42]\n [13 23 33 43]]\n```\n:::\n:::\n\n\n::: {#cae68c2f .cell execution_count=34}\n``` {.python .cell-code}\n# 브로드캐스팅3 : 두 배열의 열 크기가 다르므로 브로드캐스팅 불가능\n#arr1 = np.array([[1, 2, 3],\n#                 [4, 5, 6]])               # shape : (2, 3)\n#arr2 = np.array([10, 20, 30, 40])          # shape: (4,) → (1, 4)로 간주\n#\n#print(arr1.shape, arr2.shape)\n#print(arr1 + arr2)\n```\n:::\n\n\n::: {#e83cb9de .cell execution_count=35}\n``` {.python .cell-code}\n# 브로드캐스팅 : 3차원 + 1차원\narr1 = np.arange(24).reshape(2, 3, 4)      # shape : (2, 3, 4)\narr2 = np.array([10, 20, 30, 40])          # shape : (4,) → (1, 1, 4)로 간주\n\nprint(arr1.shape, arr2.shape)\nprint((arr1 + arr2).shape)                 # shaep : (2, 3, 4)\nprint(arr1 + arr2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n(2, 3, 4) (4,)\n(2, 3, 4)\n[[[10 21 32 43]\n  [14 25 36 47]\n  [18 29 40 51]]\n\n [[22 33 44 55]\n  [26 37 48 59]\n  [30 41 52 63]]]\n```\n:::\n:::\n\n\n",
    "supporting": [
      "5_numpy_files"
    ],
    "filters": [],
    "includes": {}
  }
}