[
  {
    "objectID": "index.html#python-통계자료-분석a",
    "href": "index.html#python-통계자료-분석a",
    "title": "2025년도 하계 WORKSHOP",
    "section": "Python 통계자료 분석A",
    "text": "Python 통계자료 분석A\n\n일시 : 2025년 7월 28일(월) ~ 8월 1일(금) 9:30 ~ 12:30\n장소 : 전북대학교 창조1관 202호 컴퓨터실습실"
  },
  {
    "objectID": "index.html#참고문헌",
    "href": "index.html#참고문헌",
    "title": "2025년도 하계 WORKSHOP",
    "section": "참고문헌",
    "text": "참고문헌\n\n실생활 융합 예제로 배우는 파이썬 마스터 / 김종훈, 김동건 / 2025 / 한빛아카데미\n개념잡는 데이터분석 with 머신러닝 / 장은실, 양숙희, 오경선 / 2023 / 배움터\n데이터 과학을 위한 파이썬 프로그래밍 / 최성철 / 2023 / 한빛아카데미\n파이썬과 함께하는 생활 속의 통계학 / 안기수 / 2022 / (주)생능\n혼자 공부하는 파이썬(개정판) / 윤인성 / 2022 / 한빛아카데미"
  },
  {
    "objectID": "9_matplotlib.html",
    "href": "9_matplotlib.html",
    "title": "\n\nMatplotlib\n",
    "section": "",
    "text": "Matplotlib"
  },
  {
    "objectID": "9_matplotlib.html#데이터-시각화",
    "href": "9_matplotlib.html#데이터-시각화",
    "title": "\n\nMatplotlib\n",
    "section": "9.1. 데이터 시각화",
    "text": "9.1. 데이터 시각화\n\n데이터 시각화(data visualization)\n\n데이터 분석 결과를 쉽게 이해할 수 있도록 표현하고 전달되는 과정\n복잡한 정보를 한 눈에 파악하고, 숨겨진 패턴이나 관계를 드러냄\n탐색적 자료 분석(EDA), 결과 해석, 의사결정 등에 폭넓게 활용"
  },
  {
    "objectID": "9_matplotlib.html#시각화-옵션",
    "href": "9_matplotlib.html#시각화-옵션",
    "title": "\n\nMatplotlib\n",
    "section": "9.2. 시각화 옵션",
    "text": "9.2. 시각화 옵션\n\nMatplotlib\n\n넘파이 배열을 기반으로 개발된 다중 플랫폼 데이터 시각화 라이브러리\n다양한 운영체제와 그래픽 백엔드에서 안정적으로 작동함\n일반적으로 Pandas의 데이터프레임과 함께 자주 사용됨\n\n\n\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\n# 시각화 옵션1 : 제목\nxdata = [3, 5, 7, 9]\nydata = [2, 4, 6, 8]\n\nplt.figure(figsize=(5, 3))\nplt.title('Line Graph')\nplt.plot(xdata, ydata)\nplt.show()\n\n\n\n\n\n\n\n\n\n# 시각화 옵션2 : 범례\n# plot()의 label 속성에 범례에 표시할 문자열을 작성\ndata1 = [1, 3, 5, 7]\ndata2 = [9, 7, 5, 3]\n\nplt.figure(figsize=(5, 3))\nplt.title('Legend Properties')\nplt.plot(data1, label='Salary')\nplt.plot(data2, label='Prices')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n# 시각화 옵션3 : 색상\n# plot()의 color 속성에 색상 설정\nplt.figure(figsize=(5, 3))\nplt.title('Color Properties')\nplt.plot(xdata, ydata, color='green')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 시각화 옵션4 : 선 모양\n# plot()의 linestyle 속성에 선 모양을 '-', '--', '-.', ':' 등으로 설정\nplt.figure(figsize=(5, 3))\nplt.title('Line shape Properties')\nplt.plot(data1, color='b', linestyle='--', label='dashed line')\nplt.plot(data2, color='r', linestyle=':', label='dotted line')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n# 시각화 옵션5 : 마커\n# plot()의 marker 속성에 마커를 '.', 'o', '^', 'S', 'D', 'x', '+', '*' 등으로 설정\nplt.figure(figsize=(5, 3))\nplt.title('Marker Properties')\nplt.plot(data1, color='c', marker='o', label='circle marker')\nplt.plot(data2, 'ms:', label='square marker')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n# 시각화 옵션6 : x축 및 y축 이름\nxdata = [3, 5, 7, 9]\nydata = [1, 3, 5, 7]\n\nplt.figure(figsize=(5, 3))\nplt.title('Axis name Properties')\nplt.plot(xdata, ydata)\nplt.xlabel('X value')\nplt.ylabel('Y value')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 시각화 옵션7 : 축 범위\nxdata = [15, 25, 35, 45]\nydata = [2, 4, 6, 8]\n\nplt.figure(figsize=(5, 3))\nplt.title('X, Y range Properties')\nplt.plot(xdata, ydata, 'b--o', markersize=7)\nplt.xlim(10, 50)\nplt.ylim(0, 10)\nplt.show()\n\n\n\n\n\n\n\n\n\n# 시각화 옵션8 : 내장 시각화 옵션\n# Pandas 라이브러리의 plot() 메소드를 이용하여 그래프를 그릴 수 있음\nmy_score = [[60, 90, 95], [65, 85, 90], [80, 75, 100],\n            [95, 90, 85], [85, 80, 65]]\nsubject = ['1st', '2nd', '3rd']\ndf = pd.DataFrame(my_score, columns=subject)\n\n# 선 그래프\ndf.plot(kind='line', figsize=(5, 3))\nplt.show()\n\n\n\n\n\n\n\n\n\n# 상자수염 그래프\ndf.plot(kind='box', figsize=(5, 3))\nplt.show()\n\n\n\n\n\n\n\n\n\n# 커널 밀도 그래프\ndf.plot(kind='kde', figsize=(5, 3))\nplt.show()"
  },
  {
    "objectID": "9_matplotlib.html#선-그래프",
    "href": "9_matplotlib.html#선-그래프",
    "title": "\n\nMatplotlib\n",
    "section": "9.3. 선 그래프",
    "text": "9.3. 선 그래프\n\n일반적으로 시간에 따라 연속적으로 변화하는 데이터를 시각화할 때 사용함\n\nx축에는 시간, y축에는 수치형 변수를 지정함\n시간의 흐름에 따라 데이터의 값은 증가/감소하는가?\n계절에 따른 특정 패턴이 존재하는가? 눈에 띄는 변화 시점이 있는가?\n\n\n\n\n## 실습 데이터 : air_quality 데이터셋\nair_quality = pd.read_csv('https://raw.githubusercontent.com/pandas-dev/pandas/main/doc/data/air_quality_no2_long.csv')\n\n\n# city : 측정 도시\n# country : 측정 국가\n# date.utc : 측정 일시(UTC)\n# location : 측정 위치\n# parameter : 측정 항목\n# value : 측정 값\n# unit : 측정 단위\nprint(air_quality.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 2068 entries, 0 to 2067\nData columns (total 7 columns):\n #   Column     Non-Null Count  Dtype  \n---  ------     --------------  -----  \n 0   city       2068 non-null   object \n 1   country    2068 non-null   object \n 2   date.utc   2068 non-null   object \n 3   location   2068 non-null   object \n 4   parameter  2068 non-null   object \n 5   value      2068 non-null   float64\n 6   unit       2068 non-null   object \ndtypes: float64(1), object(6)\nmemory usage: 113.2+ KB\nNone\n\n\n\nprint(air_quality.head())\n\n    city country                   date.utc location parameter  value   unit\n0  Paris      FR  2019-06-21 00:00:00+00:00  FR04014       no2   20.0  µg/m³\n1  Paris      FR  2019-06-20 23:00:00+00:00  FR04014       no2   21.8  µg/m³\n2  Paris      FR  2019-06-20 22:00:00+00:00  FR04014       no2   26.5  µg/m³\n3  Paris      FR  2019-06-20 21:00:00+00:00  FR04014       no2   24.9  µg/m³\n4  Paris      FR  2019-06-20 20:00:00+00:00  FR04014       no2   21.4  µg/m³\n\n\n\nair_quality['city'].value_counts()\n\ncity\nParis        1004\nLondon        969\nAntwerpen      95\nName: count, dtype: int64\n\n\n\nair_quality['parameter'].value_counts()\n\nparameter\nno2    2068\nName: count, dtype: int64\n\n\n\n# date.utc 열을 datetime 형식으로 변환\nair_quality['date.utc'] = pd.to_datetime(air_quality['date.utc'])\n\n\nprint(air_quality.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 2068 entries, 0 to 2067\nData columns (total 7 columns):\n #   Column     Non-Null Count  Dtype              \n---  ------     --------------  -----              \n 0   city       2068 non-null   object             \n 1   country    2068 non-null   object             \n 2   date.utc   2068 non-null   datetime64[ns, UTC]\n 3   location   2068 non-null   object             \n 4   parameter  2068 non-null   object             \n 5   value      2068 non-null   float64            \n 6   unit       2068 non-null   object             \ndtypes: datetime64[ns, UTC](1), float64(1), object(5)\nmemory usage: 113.2+ KB\nNone\n\n\n\nprint(air_quality.head())\n\n    city country                  date.utc location parameter  value   unit\n0  Paris      FR 2019-06-21 00:00:00+00:00  FR04014       no2   20.0  µg/m³\n1  Paris      FR 2019-06-20 23:00:00+00:00  FR04014       no2   21.8  µg/m³\n2  Paris      FR 2019-06-20 22:00:00+00:00  FR04014       no2   26.5  µg/m³\n3  Paris      FR 2019-06-20 21:00:00+00:00  FR04014       no2   24.9  µg/m³\n4  Paris      FR 2019-06-20 20:00:00+00:00  FR04014       no2   21.4  µg/m³\n\n\n\n# 선 그래프1 : Paris의 NO2 농도 변화\nparis_data = air_quality[air_quality['city'] == 'Paris']\n\nplt.figure(figsize=(6, 3))\nplt.plot(paris_data['date.utc'], paris_data['value'])\nplt.title('NO₂ levels in Paris')\nplt.ylabel('NO₂ (µg/m³)')\nplt.xticks(fontsize=10, rotation=30)\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n# 선 그래프2 : 세 도시의 NO2 농도 변화\ncities = ['Paris', 'London', 'Antwerpen']\ncolors = ['steelblue', 'green', 'indianred']\n\nplt.figure(figsize=(6, 3))\n\nfor i, city in enumerate(cities):\n    city_data = air_quality[air_quality['city'] == city]\n    plt.plot(city_data['date.utc'], city_data['value'],\n             label=city, color=colors[i],\n             linewidth=1, alpha=0.7)\n\nplt.title('NO₂ levels in Paris, London, and Antwerpen')\nplt.ylabel('NO₂ (µg/m³)')\nplt.legend(loc='upper right', fontsize=7)\nplt.xticks(fontsize=10, rotation=30)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "9_matplotlib.html#막대-그래프",
    "href": "9_matplotlib.html#막대-그래프",
    "title": "\n\nMatplotlib\n",
    "section": "9.4. 막대 그래프",
    "text": "9.4. 막대 그래프\n\n일반적으로 집단 간 비교나 범주형 변수를 시각화할 때 사용함\n가독성 측면에서 항목의 개수가 적으면 세로 막대, 많으면 가로 막대가 유리함\n\n\n\n# 막대 그래프1 : 도시의 측정 빈도\ncity_counts = air_quality['city'].value_counts()\n\nplt.figure(figsize=(5, 3))\nplt.bar(city_counts.index, city_counts.values, color=['steelblue', 'seagreen', 'indianred'])\nplt.title('Frequency of Measurements by City')\nplt.ylabel('Frequency')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n# 막대 그래프2 : 도시별 평균 NO₂ 농도\ncity_avg = air_quality.groupby('city')['value'].mean()\n\nplt.figure(figsize=(5, 3))\nplt.bar(city_avg.index, city_avg.values, color=['steelblue', 'seagreen', 'indianred'])\nplt.title('Average NO₂ Levels by City')\nplt.ylabel('Average NO₂ (µg/m³)')\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "9_matplotlib.html#히스토그램",
    "href": "9_matplotlib.html#히스토그램",
    "title": "\n\nMatplotlib\n",
    "section": "9.5. 히스토그램",
    "text": "9.5. 히스토그램\n\n수치형 변수의 분포를 시각화할 때 사용함\n데이터를 일정한 구간(bin)으로 나누고, 각 구간에 속하는 값들의 빈도를 막대의 높이로 나타냄\n\n\n\n# 히스토그램1 : Paris의 NO2 농도 분포\nparis_data = air_quality[air_quality['city'] == 'Paris']\n\nplt.figure(figsize=(5, 3))\nplt.hist(paris_data['value'], bins=15)\nplt.title('Distribution of NO₂ in Paris')\nplt.xlabel('NO₂ (µg/m³)')\nplt.ylabel('Frequency')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n# 히스토그램, 다중 그래프 : 세 도시의 NO2 농도 분포\ncities = ['Paris', 'London', 'Antwerpen']\ncolors = ['steelblue', 'green', 'indianred']\n\nplt.figure(figsize=(7, 3))\n\nfor i, city in enumerate(cities):\n    city_data = air_quality[air_quality['city'] == city]\n    plt.subplot(1, 3, i+1)\n    plt.hist(city_data['value'], density=True,\n             label=city, color=colors[i])\n    \n    plt.xlabel('NO₂ (µg/m³)')\n    plt.ylabel('Frequency')\n    plt.legend(loc='upper right')\n    plt.xlim(0, 100)\n    plt.ylim(0, 0.05)\n\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "9_matplotlib.html#상자그림",
    "href": "9_matplotlib.html#상자그림",
    "title": "\n\nMatplotlib\n",
    "section": "9.6. 상자그림",
    "text": "9.6. 상자그림\n\n수치형 변수의 분포를 시각화할 때 사용함\n다섯 숫자 요약값을 기반으로 이상값, 분포의 비대칭 여부 등을 직관적으로 파악할 수 있음\n\n\n\n\n\n# 상자그림1 : Paris의 NO2 농도 분포\nparis_data = air_quality[air_quality['city'] == 'Paris']\n\nplt.figure(figsize=(5, 3))\nplt.boxplot(paris_data['value'], vert=False, widths=0.5)\nplt.title('Distribution of NO₂ in Paris')\nplt.xlabel('NO₂ (µg/m³)')\nplt.yticks(range(1,2), ['Paris'])\nplt.show()\n\n\n\n\n\n\n\n\n\n# 상자그림2 : 세 도시의 NO2 농도 분포\ncities = ['Paris', 'London', 'Antwerpen']\ncolors = ['steelblue', 'green', 'indianred']\n\ndata = [air_quality[air_quality['city'] == city]['value'] for city in cities]\nplt.figure(figsize=(5, 3))\nbox = plt.boxplot(data, vert=False, widths=0.5)\nplt.xlabel('NO₂ (µg/m³)')\nplt.yticks(range(1,4), cities)\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "9_matplotlib.html#산점도",
    "href": "9_matplotlib.html#산점도",
    "title": "\n\nMatplotlib\n",
    "section": "9.7. 산점도",
    "text": "9.7. 산점도\n\n두 수치형 변수 간 관계를 시각화할 때 사용함\n데이터의 분포, 이상값, 변수 간 상관관계, 그룹화된 패턴 등을 직관적으로 파악할 수 있음\n\n\n\n## 실습 데이터 : tips 데이터셋\nimport seaborn as sns\ntips = sns.load_dataset('tips')\nprint(tips.head())\n\n   total_bill   tip     sex smoker  day    time  size\n0       16.99  1.01  Female     No  Sun  Dinner     2\n1       10.34  1.66    Male     No  Sun  Dinner     3\n2       21.01  3.50    Male     No  Sun  Dinner     3\n3       23.68  3.31    Male     No  Sun  Dinner     2\n4       24.59  3.61  Female     No  Sun  Dinner     4\n\n\n\n# 산점도1 : 식사 금액과 팀 금액 관계\nplt.figure(figsize=(4, 4))\nplt.scatter(tips['total_bill'], tips['tip'])\nplt.title('Scatter Plot of Total Bill vs Tip')\nplt.xlabel('Total Bill')\nplt.ylabel('Tip')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n# 산점도2 : 식사 금액과 팀 금액, 식사 시간의 관계\nplt.figure(figsize=(4, 4))\nplt.scatter(tips['total_bill'], tips['tip'],\n           c=tips['time'].map({'Lunch': 'orange', 'Dinner': 'gray'}), alpha=0.7)\nplt.title('Scatter Plot of Total Bill vs Tip')\nplt.xlabel('Total Bill')\nplt.ylabel('Tip')\nplt.tight_layout()\nplt.show()"
  },
  {
    "objectID": "7_EDA.html",
    "href": "7_EDA.html",
    "title": "\n\n기술통계\n",
    "section": "",
    "text": "기술통계"
  },
  {
    "objectID": "7_EDA.html#데이터-유형",
    "href": "7_EDA.html#데이터-유형",
    "title": "\n\n기술통계\n",
    "section": "7.1. 데이터 유형",
    "text": "7.1. 데이터 유형\n\n데이터의 특성에 따라 적용할 수 있는 분석 방법이나 시각화 기법이 달라지므로, 제일 먼저 변수의 유형을 파악해야 함\n\n\n\n\n\n\n\n\n\n\n구분\n설명\n예시\n\n\n\n\n범주형 변수 (categorical variable)\n- 고정된 범주(집단) 중 하나의 값을 가지는 변수 - 기본적으로 숫자로 표현할 수 없고, 대소 비교나 산술 연산이 적용되지 않음 - 범주형 변수를 숫자로 표기했다고 해서 계산 가능한 수치형 변수가 되는 것은 아님\n- 성별(남성, 여성) - 종교(있음, 없음)\n\n\n수치형 변수 (numerical variagle)\n- 연산 가능한 수치 값을 가지는 변수 - 대소 비교가 가능하고, 산술 연산이 가능함\n- 키(cm) - 몸무게(kg)"
  },
  {
    "objectID": "7_EDA.html#변수-요약",
    "href": "7_EDA.html#변수-요약",
    "title": "\n\n기술통계\n",
    "section": "7.2. 변수 요약",
    "text": "7.2. 변수 요약\n\n7.2.1. 범주형 변수 요약\n\n빈도표 : 하나의 범주형 변수의 분포를 파악하기 위해 범주별 빈도를 정리한 표\n분할표 : 두 개의 범주형 변수의 분포를 파악하기 위해 한 변수의 범주는 행에, 다른 변수의 범주는 열에 배치하여 교차되는 칸에 해당 빈도를 정리한 표\n\n\n\nimport numpy as np\nimport pandas as pd\n\n\n## 실습 데이터 : tips 데이터셋\nimport seaborn as sns\ntips = sns.load_dataset('tips')\n\n\n# total_bill: 식사 금액\n# tip: 팁 금액\n# sex: 성별\n# smoker: 흡연 여부\n# day: 요일\n# time: 식사 시간(Lunch, Dinner)\n# size: 식사 인원 수\nprint(tips.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 244 entries, 0 to 243\nData columns (total 7 columns):\n #   Column      Non-Null Count  Dtype   \n---  ------      --------------  -----   \n 0   total_bill  244 non-null    float64 \n 1   tip         244 non-null    float64 \n 2   sex         244 non-null    category\n 3   smoker      244 non-null    category\n 4   day         244 non-null    category\n 5   time        244 non-null    category\n 6   size        244 non-null    int64   \ndtypes: category(4), float64(2), int64(1)\nmemory usage: 7.4 KB\nNone\n\n\n\n# 빈도표1 : 요일별 주문 수\nprint(tips.value_counts('day'))\n\nday\nSat     87\nSun     76\nThur    62\nFri     19\nName: count, dtype: int64\n\n\n\n# 빈도표2 : 요일별 주문 비율\nprint(tips.value_counts('day', normalize=True))\n\nday\nSat     0.356557\nSun     0.311475\nThur    0.254098\nFri     0.077869\nName: proportion, dtype: float64\n\n\n\n# 빈도표3 : 요일별 주문 수 및 비율 (범주 순서 지정)\ndays = ['Thur', 'Fri', 'Sat', 'Sun']\ncat_type = pd.CategoricalDtype(categories=days, ordered=True)\ntips['day'] = tips['day'].astype(cat_type)\n\nfreqency = tips['day'].value_counts().sort_index()\nproportion = tips['day'].value_counts(normalize=True).sort_index()\n\nsummary = pd.DataFrame({'빈도': freqency, '비율': proportion})\nprint(summary)\n\n      빈도        비율\nday               \nThur  62  0.254098\nFri   19  0.077869\nSat   87  0.356557\nSun   76  0.311475\n\n\n\n# 교차표1 : 요일에 따른 식사 시간 빈도\nprint(pd.crosstab(tips['day'], tips['time']))\n\ntime  Lunch  Dinner\nday                \nThur     61       1\nFri       7      12\nSat       0      87\nSun       0      76\n\n\n\n# 교차표2 : 요일에 따른 식사 시간 비율 (전체 %)\nprint(pd.crosstab(tips['day'], tips['time'], normalize=True))\n\ntime     Lunch    Dinner\nday                     \nThur  0.250000  0.004098\nFri   0.028689  0.049180\nSat   0.000000  0.356557\nSun   0.000000  0.311475\n\n\n\n# 교차표3 : 요일에 따른 식사 시간 비율 (행 기준 %)\nprint(pd.crosstab(tips['day'], tips['time'], normalize='index'))\n\ntime     Lunch    Dinner\nday                     \nThur  0.983871  0.016129\nFri   0.368421  0.631579\nSat   0.000000  1.000000\nSun   0.000000  1.000000\n\n\n\n# 교차표4 : 요일에 따른 식사 시간 비율 (열 기준 %)\nprint(pd.crosstab(tips['day'], tips['time'], normalize='columns'))\n\ntime     Lunch    Dinner\nday                     \nThur  0.897059  0.005682\nFri   0.102941  0.068182\nSat   0.000000  0.494318\nSun   0.000000  0.431818\n\n\n\n\n\n7.2.2. 수치형 변수 요약\n\n중심위치 : 자료를 하나의 숫자로 표현할 수 있는 값으로, 분포의 중심을 나타냄\n\n평균(mean) : 모든 값을 더한 후 데이터 개수로 나눈 값으로, 이상값의 영향을 크게 받음\n중앙값(median) : 데이터를 크기 순으로 정렬했을 때 중앙에 위치하는 값으로, 이상값의 영향을 거의 받지 않음\n\n\n\n\n산포도 : 데이터가 흩어져 있는 정도로, 중심위치의 대표성을 평가하는데 중요함\n\n분산(variance) : 각 데이터가 평균과 얼마나 떨어져 있는지 제곱한 값들의 평균\n표준편차(standard deviation) : 분산의 양의 제곱근으로, 평균과 단위가 같아 해석이 용이함\n산포도가 작으면 데이터들이 중심위치에 모여 있다는 것을 의미함\n\n\n\n\n사분위수(quartiles) : 데이터를 4등분하는 값\n\n최소값\n1사분위수(Q₁) : 데이터의 25% 순서에 있는 값\n중앙값\n3사분위수(Q₃) : 데이터의 75% 순서에 있는 값\n최대값\n\n사분위수범위(IQR) : Q₃ - Q₁으로, 중앙값에 대한 산포도를 나타냄\n\n\n\n\n\n분포의 모양\n\n왜도(skewness)\n\n데이터의 비대칭 정도를 나타냄\n0이면 대칭, 음수이면 왼쪽으로 꼬리가 긴 분포(skewed to left), 양수이면 오른쪽으로 꼬리가 긴 분포(skewed to right)임\n\n첨도(kurtosis)\n\n데이터가 중심위치에 얼마나 모여 있는가를 나타냄\n0이면 정규분포와 유사, 양수이면 중심에 많이 모여 있음(뾰족함), 음수이면 넓게 퍼져있음(완만함)\n[참고]) Python은 초과 첨도를 기준으로 하여, 정규분포를 0으로 간주함\n\n\n\n\n\nfrom scipy import stats\n\n\n# 요약 통계1 : 식사 금액 분포 \nprint(tips['total_bill'].describe())\n\ncount    244.000000\nmean      19.785943\nstd        8.902412\nmin        3.070000\n25%       13.347500\n50%       17.795000\n75%       24.127500\nmax       50.810000\nName: total_bill, dtype: float64\n\n\n\n# 요약 통계2 : 팁 금액 분포\nsummary = stats.describe(tips['tip'])\nprint(f'nobs: {summary.nobs}')\nprint(f'min-max: {summary.minmax}')\nprint(f'mean: {summary.mean:.2f}')\nprint(f'variance: {summary.variance:.2f}')\nprint(f'skewness: {summary.skewness:.2f}')\nprint(f'kurtosis: {summary.kurtosis:.2f}')\n\nnobs: 244\nmin-max: (1.0, 10.0)\nmean: 3.00\nvariance: 1.91\nskewness: 1.46\nkurtosis: 3.55"
  },
  {
    "objectID": "7_EDA.html#변수-간-관계",
    "href": "7_EDA.html#변수-간-관계",
    "title": "\n\n기술통계\n",
    "section": "7.3. 변수 간 관계",
    "text": "7.3. 변수 간 관계\n\n7.3.1. 집단별 비교\n\n집단별로 수치형 변수의 분포(평균, 중앙값, 표준편차, 사분위수 등)를 비교함으로써 집단 간 차이를 파악할 수 있음\n\n\n\n# 흡연 여부별 팁 금액 분포\nprint(tips.groupby('smoker', observed=True)['total_bill'].describe())\n\n        count       mean       std   min     25%    50%     75%    max\nsmoker                                                                \nYes      93.0  20.756344  9.832154  3.07  13.420  17.92  26.860  50.81\nNo      151.0  19.188278  8.255582  7.25  13.325  17.59  22.755  48.33\n\n\n\n\n\n7.3.2. 상관관계\n\n상관관계(correlation)\n\n두 수치형 변수 간 선형적인 관계(linear relationship)를 나타냄\n상관계수(correlation coefficient)\n\n두 변수 간 상관관계를 수치로 나타낸 지표\n변수 측정 단위의 영향을 받지 않음\n\n\n\n\n\n상관계수의 성질\n\n상관계수 r은 항상 -1에서 +1 사이의 값을 가짐\n절대값 |r|은 선형성의 강도를 나타내며, 1에 가까울수록 강한 상관관계를 의미함\n부호는 선형 관계의 방향을 나타냄\n\nr &gt; 0 : 양의 상관관계(한 변수가 증가할 때 다른 변수도 증가)\nr &lt; 0 : 음의 상관관계(한 변수가 증가할 때 다른 변수는 감소)\nr ≈ 0 : 상관관계 없음(한 변수가 증가할 때 다른 변수는 영향을 받지 않음)\n\n\n\n\n\n\n\n# 상관관계1 : 식사 금액과 팁 금액 간 상관계수\nfrom scipy.stats import pearsonr\nr, p = pearsonr(tips['total_bill'], tips['tip'])\nprint(f'상관계수: {r:.2f}, p-value: {p:.3f}')\n\n상관계수: 0.68, p-value: 0.000\n\n\n\n# 상관관계2 : 식사 금액, 식사 인원 수와 팁 금액 간 상관계수\ntips[['total_bill', 'size', 'tip']].corr()\n\n\n\n\n\n\n\n\ntotal_bill\nsize\ntip\n\n\n\n\ntotal_bill\n1.000000\n0.598315\n0.675734\n\n\nsize\n0.598315\n1.000000\n0.489299\n\n\ntip\n0.675734\n0.489299\n1.000000"
  },
  {
    "objectID": "7_EDA.html#결측값-처리",
    "href": "7_EDA.html#결측값-처리",
    "title": "\n\n기술통계\n",
    "section": "7.4. 결측값 처리",
    "text": "7.4. 결측값 처리\n\n결측값(missing value)\n\nPython에서는 누락된 데이터를 NaN(Not a Number)로 표기하며, 연산 시 자동으로 제외함\n데이터프레임에서 isna(), isnull() 메소드를 이용하면 결측값을 확인할 수 있음\n\n\n\n\n결측값 처리 방법\n\n가장 단순한 방법은 dropna() 메소드를 이용하여 결측값이 포함된 행이나 열을 삭제하는 것임\n\naxis=0이면 행, axis=1이면 열을 삭제함\n\nfillna() 메소드를 이용하여 결측값을 최빈값이나 평균, 중앙값으로 대체할 수도 있음\n\n\n\n\n## 실습 데이터 : titanic\ntitanic = sns.load_dataset('titanic')\n\n\n# survived: 생존 여부(0, 1)\n# pclass: 객실 등급(1, 2, 3)\n# sex: 성별\n# age: 나이\n# sibsp: 함께 탑승한 형제자매, 배우자 수\n# parch: 함께 탑승한 부모, 자식 수\n# fare: 요금\n# embarked: 탑승 항구(S, C, Q)\n# class: 객실 등급(First, Second, Third)\n# who: 사람 구분(man, woman, child)\n# adult_male: 성인 남자 여부(True, False)\n# deck: 갑판\n# embark_town: 탑승 항구(Southhampton, Cherbourg, Queenstown)\n# alive: 생존여부(no, yes)\n# alone: 1인 탑승 여부(True, False)\ntitanic.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 891 entries, 0 to 890\nData columns (total 15 columns):\n #   Column       Non-Null Count  Dtype   \n---  ------       --------------  -----   \n 0   survived     891 non-null    int64   \n 1   pclass       891 non-null    int64   \n 2   sex          891 non-null    object  \n 3   age          714 non-null    float64 \n 4   sibsp        891 non-null    int64   \n 5   parch        891 non-null    int64   \n 6   fare         891 non-null    float64 \n 7   embarked     889 non-null    object  \n 8   class        891 non-null    category\n 9   who          891 non-null    object  \n 10  adult_male   891 non-null    bool    \n 11  deck         203 non-null    category\n 12  embark_town  889 non-null    object  \n 13  alive        891 non-null    object  \n 14  alone        891 non-null    bool    \ndtypes: bool(2), category(2), float64(2), int64(4), object(5)\nmemory usage: 80.7+ KB\n\n\n\n# 결측값 확인\ntitanic[titanic['embarked'].isna()]\n\n\n\n\n\n\n\n\nsurvived\npclass\nsex\nage\nsibsp\nparch\nfare\nembarked\nclass\nwho\nadult_male\ndeck\nembark_town\nalive\nalone\n\n\n\n\n61\n1\n1\nfemale\n38.0\n0\n0\n80.0\nNaN\nFirst\nwoman\nFalse\nB\nNaN\nyes\nTrue\n\n\n829\n1\n1\nfemale\n62.0\n0\n0\n80.0\nNaN\nFirst\nwoman\nFalse\nB\nNaN\nyes\nTrue\n\n\n\n\n\n\n\n\n# 각 열별 결측값 개수 확인\n# 부울형은 산술 연산 시 True는 1, False는 0으로 계산되므로\n# isna() 결과에 sum()을 적용하면 결측값 개수가 계산됨\ntitanic.isna().sum()\n\nsurvived         0\npclass           0\nsex              0\nage            177\nsibsp            0\nparch            0\nfare             0\nembarked         2\nclass            0\nwho              0\nadult_male       0\ndeck           688\nembark_town      2\nalive            0\nalone            0\ndtype: int64\n\n\n\n# 결측값이 많이 포함된 열 삭제\ntitanic.drop('deck', axis=1, inplace=True)\ntitanic.columns\n\nIndex(['survived', 'pclass', 'sex', 'age', 'sibsp', 'parch', 'fare',\n       'embarked', 'class', 'who', 'adult_male', 'embark_town', 'alive',\n       'alone'],\n      dtype='object')\n\n\n\n# age 변수를 제외한 변수들 중 결측값이 하나라도 포함된 행 삭제\ncols = titanic.columns.difference(['age'])\ntitanic_new = titanic.dropna(subset=cols, how='any')\ntitanic_new.isna().sum()\n\nsurvived         0\npclass           0\nsex              0\nage            177\nsibsp            0\nparch            0\nfare             0\nembarked         0\nclass            0\nwho              0\nadult_male       0\nembark_town      0\nalive            0\nalone            0\ndtype: int64\n\n\n\n# 결측값을 최빈값으로 대체\nmode = titanic['embarked'].mode()[0]\ntitanic['embarked'] = titanic['embarked'].fillna(mode)\ntitanic.isna().sum()\n\nsurvived         0\npclass           0\nsex              0\nage            177\nsibsp            0\nparch            0\nfare             0\nembarked         0\nclass            0\nwho              0\nadult_male       0\nembark_town      2\nalive            0\nalone            0\ndtype: int64\n\n\n\n# 결측값을 중앙값으로 대체\nmedian = titanic.groupby(['sex', 'who'])['age'].transform('median')\ntitanic['age'] = titanic['age'].fillna(median)\ntitanic.isna().sum()\n\nsurvived       0\npclass         0\nsex            0\nage            0\nsibsp          0\nparch          0\nfare           0\nembarked       0\nclass          0\nwho            0\nadult_male     0\nembark_town    2\nalive          0\nalone          0\ndtype: int64"
  },
  {
    "objectID": "7_EDA.html#이상값-처리",
    "href": "7_EDA.html#이상값-처리",
    "title": "\n\n기술통계\n",
    "section": "7.5. 이상값 처리",
    "text": "7.5. 이상값 처리\n\n이상값(outlier)\n\n대부분의 데이터가 분포된 범위를 벗어나 극단적으로 크거나 작은 값\n데이터 분석과 모델링 과정에서 결과에 큰 영향을 미칠 수 있음\n\n\n\n\n이상값 탐지 방법\n\n사분위수범위(IQR) 활용 : (Q₁-1.5×IQR, Q₃+1.5×IQR) 범위를 벗어나는 값을 이상값으로 판단\n표준점수(Z-score) 활용 : 분포가 대칭일때, 일반적으로 |Z|&gt;3인 값을 이상값으로 판단\n\n\n\n\n이상값 처리 방법\n\n이상값이 소수이고 데이터 손실이 크지 않다면 해당 데이터를 삭제\n평균, 중앙값 등 적절한 값으로 대체 가능\n로그 변환, 제곱근 변환 등 데이터 변환 기법 활용\n\n\n\n\n# 이상값 반환 함수1 : 사분위수 범위(IQR) 활용\ndef iqr_outlier(data, column):\n    col_data = data[column].dropna()\n    Q1 = col_data.quantile(0.25)\n    Q3 = col_data.quantile(0.75)\n    IQR = Q3 - Q1\n    lower_bound = Q1 - 1.5 * IQR\n    upper_bound = Q3 + 1.5 * IQR\n    outliers = data[(data[column] &lt; lower_bound) | (data[column] &gt; upper_bound)]\n    return outliers\n\n# 각 열별 이상값 개수 확인\nfor column in titanic.select_dtypes(include='number').columns:\n    outlier = iqr_outlier(titanic, column)\n    print(f'{column} 변수의 이상값 개수: {len(outlier)}')\n\nsurvived 변수의 이상값 개수: 0\npclass 변수의 이상값 개수: 0\nage 변수의 이상값 개수: 66\nsibsp 변수의 이상값 개수: 46\nparch 변수의 이상값 개수: 213\nfare 변수의 이상값 개수: 116\n\n\n\n# age 변수의 이상값을 제외한 데이터프레임\noutliers_age = iqr_outlier(titanic, 'age')\ntitanic_new = titanic.drop(index=outliers_age.index)\ntitanic_new\n\n\n\n\n\n\n\n\nsurvived\npclass\nsex\nage\nsibsp\nparch\nfare\nembarked\nclass\nwho\nadult_male\nembark_town\nalive\nalone\n\n\n\n\n0\n0\n3\nmale\n22.0\n1\n0\n7.2500\nS\nThird\nman\nTrue\nSouthampton\nno\nFalse\n\n\n1\n1\n1\nfemale\n38.0\n1\n0\n71.2833\nC\nFirst\nwoman\nFalse\nCherbourg\nyes\nFalse\n\n\n2\n1\n3\nfemale\n26.0\n0\n0\n7.9250\nS\nThird\nwoman\nFalse\nSouthampton\nyes\nTrue\n\n\n3\n1\n1\nfemale\n35.0\n1\n0\n53.1000\nS\nFirst\nwoman\nFalse\nSouthampton\nyes\nFalse\n\n\n4\n0\n3\nmale\n35.0\n0\n0\n8.0500\nS\nThird\nman\nTrue\nSouthampton\nno\nTrue\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n886\n0\n2\nmale\n27.0\n0\n0\n13.0000\nS\nSecond\nman\nTrue\nSouthampton\nno\nTrue\n\n\n887\n1\n1\nfemale\n19.0\n0\n0\n30.0000\nS\nFirst\nwoman\nFalse\nSouthampton\nyes\nTrue\n\n\n888\n0\n3\nfemale\n30.0\n1\n2\n23.4500\nS\nThird\nwoman\nFalse\nSouthampton\nno\nFalse\n\n\n889\n1\n1\nmale\n26.0\n0\n0\n30.0000\nC\nFirst\nman\nTrue\nCherbourg\nyes\nTrue\n\n\n890\n0\n3\nmale\n32.0\n0\n0\n7.7500\nQ\nThird\nman\nTrue\nQueenstown\nno\nTrue\n\n\n\n\n825 rows × 14 columns\n\n\n\n\n# 이상값 반환 함수2 : Z-score 활용\ndef z_outlier(df, c, t=3):\n    from scipy.stats import zscore\n    z = zscore(df[c].dropna())\n    return df.loc[df[c].dropna().index[(abs(z) &gt; t)]]\n    \nfor column in titanic.select_dtypes(include='number').columns:\n    outlier = z_outlier(titanic, column)\n    print(f'{column} 변수의 이상값 개수: {len(outlier)}')\n\nsurvived 변수의 이상값 개수: 0\npclass 변수의 이상값 개수: 0\nage 변수의 이상값 개수: 7\nsibsp 변수의 이상값 개수: 30\nparch 변수의 이상값 개수: 15\nfare 변수의 이상값 개수: 20\n\n\n\n# age 변수의 이상값을 제외한 데이터프레임\noutliers_age = z_outlier(titanic, 'age')\ntitanic_new = titanic.drop(index=outliers_age.index)\ntitanic_new\n\n\n\n\n\n\n\n\nsurvived\npclass\nsex\nage\nsibsp\nparch\nfare\nembarked\nclass\nwho\nadult_male\nembark_town\nalive\nalone\n\n\n\n\n0\n0\n3\nmale\n22.0\n1\n0\n7.2500\nS\nThird\nman\nTrue\nSouthampton\nno\nFalse\n\n\n1\n1\n1\nfemale\n38.0\n1\n0\n71.2833\nC\nFirst\nwoman\nFalse\nCherbourg\nyes\nFalse\n\n\n2\n1\n3\nfemale\n26.0\n0\n0\n7.9250\nS\nThird\nwoman\nFalse\nSouthampton\nyes\nTrue\n\n\n3\n1\n1\nfemale\n35.0\n1\n0\n53.1000\nS\nFirst\nwoman\nFalse\nSouthampton\nyes\nFalse\n\n\n4\n0\n3\nmale\n35.0\n0\n0\n8.0500\nS\nThird\nman\nTrue\nSouthampton\nno\nTrue\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n886\n0\n2\nmale\n27.0\n0\n0\n13.0000\nS\nSecond\nman\nTrue\nSouthampton\nno\nTrue\n\n\n887\n1\n1\nfemale\n19.0\n0\n0\n30.0000\nS\nFirst\nwoman\nFalse\nSouthampton\nyes\nTrue\n\n\n888\n0\n3\nfemale\n30.0\n1\n2\n23.4500\nS\nThird\nwoman\nFalse\nSouthampton\nno\nFalse\n\n\n889\n1\n1\nmale\n26.0\n0\n0\n30.0000\nC\nFirst\nman\nTrue\nCherbourg\nyes\nTrue\n\n\n890\n0\n3\nmale\n32.0\n0\n0\n7.7500\nQ\nThird\nman\nTrue\nQueenstown\nno\nTrue\n\n\n\n\n884 rows × 14 columns\n\n\n\n\n# [참고] 변수 분포의 왜도를 확인하고, 적절한 이상값 탐지 방법(IQR, Z-score)을 선택\nfor column in titanic.select_dtypes(include='number').columns:\n    print(f'{column} 변수의 왜도: {stats.skew(titanic[column]):.3f}')\n\nsurvived 변수의 왜도: 0.478\npclass 변수의 왜도: -0.629\nage 변수의 왜도: 0.420\nsibsp 변수의 왜도: 3.689\nparch 변수의 왜도: 2.744\nfare 변수의 왜도: 4.779"
  },
  {
    "objectID": "5_numpy.html",
    "href": "5_numpy.html",
    "title": "\n\nNumPy\n",
    "section": "",
    "text": "NumPy"
  },
  {
    "objectID": "5_numpy.html#넘파이-배열",
    "href": "5_numpy.html#넘파이-배열",
    "title": "\n\nNumPy\n",
    "section": "5.1. 넘파이 배열",
    "text": "5.1. 넘파이 배열\n\n5.1.1. 넘파이 배열 생성\n\nNumPy\n\nNumerical Python의 약자로, C언어로 구현된 Python 라이브러리\n고성능 수치 계산, 대규모 다차원 배열 및 행렬 연산에 최적화\n\n\n\n\n넘파이 배열(ndarray)\n\n리스트처럼 데이터를 모아 저장하는 자료구조\n모든 원소가 동일한 자료형으로 저장(효율적인 메모리 관리 및 빠른 연산)\n대규모 데이터 처리에 유리함\n반복문 없이 배열 간 연산이 가능한 브로드캐스팅 및 벡터화 연산 지원\n다양한 수학 함수, 선형대수, 난수 생성 기능 제공\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nnp.array()\n리스트, 튜플 등으로부터 배열 생성\n\n\nnp.zeros()\n모든 값이 0인 배열 생성\n\n\nnp.ones()\n모든 값이 1인 배열 생성\n\n\nnp.full()\n지정한 값으로 이루어진 배열 생성\n\n\nnp.arange()\n범위를 지정하여 연속적인 값의 배열 생성(range()와 비슷)\n\n\nnp.linspace()\n시작과 끝을 기준으로, 지정한 개수만큼 일정 간격의 값으로 배열 생성\n\n\nnp.eye()\n행과 열의 크기를 지정할 수 있는 단위행렬(2차원 배열) 생성\n\n\nnp.identity()\n정방 단위행렬(2차원 배열) 생성\n\n\n\n\n\nimport numpy as np\n\n\n# 넘파이 배열 생성1\narr1 = np.array([1, 2, 3])\narr2 = np.array((6, 7, 8, 9))\nprint(arr1)\nprint(arr2)\n\n[1 2 3]\n[6 7 8 9]\n\n\n\n# 넘파이 배열 생성2\narr1 = np.zeros(5)\narr2 = np.ones(3)\narr3 = np.full(2, 5)\nprint(arr1)\nprint(arr2)\nprint(arr3)\n\n[0. 0. 0. 0. 0.]\n[1. 1. 1.]\n[5 5]\n\n\n\n# 넘파이 배열 생성3\narr1 = np.arange(10)\narr2 = np.arange(3, 6)\narr3 = np.arange(1, 11, 2)\narr4 = np.arange(0, 1, 0.1)\nprint(arr1)\nprint(arr2)\nprint(arr3)\nprint(arr4)\n\n[0 1 2 3 4 5 6 7 8 9]\n[3 4 5]\n[1 3 5 7 9]\n[0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]\n\n\n\n# 넘파이 배열 생성4\narr = np.linspace(0, 1, 5)\nprint(arr)\n\n[0.   0.25 0.5  0.75 1.  ]\n\n\n\n# 넘파이 배열 생성5\narr1 = np.eye(3)\narr2 = np.eye(3, 4, k=1)\nprint(arr1)\nprint(arr2)\n\n[[1. 0. 0.]\n [0. 1. 0.]\n [0. 0. 1.]]\n[[0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n\n\n\n# 넘파이 배열 생성6 : np.identity()는 np.eye()의 특수한 경우\narr = np.identity(4)\nprint(arr)\n\n[[1. 0. 0. 0.]\n [0. 1. 0. 0.]\n [0. 0. 1. 0.]\n [0. 0. 0. 1.]]\n\n\n\n\n\n5.1.2. 넘파이 배열 속성\n\n\n\n속성\n설명\n\n\n\n\n.dtype\n배열 원소의 자료형\n\n\n.ndim\n배열의 차원 수\n\n\n.shape\n배열의 모양(행, 열)\n\n\n.size\n배열의 전체 원소 개수\n\n\n.itemsize\n원소 하나의 메모리 크기\n\n\n\n\n\n# 넘파이 배열 속성\narr = np.array([[1, 2, 3], [4, 5, 6]])       # 2차원 배열\nprint(arr)\nprint(arr.dtype)\nprint(arr.ndim)\nprint(arr.shape)\nprint(arr.size)\nprint(arr.itemsize)\n\n[[1 2 3]\n [4 5 6]]\nint32\n2\n(2, 3)\n6\n4"
  },
  {
    "objectID": "5_numpy.html#차원과-축",
    "href": "5_numpy.html#차원과-축",
    "title": "\n\nNumPy\n",
    "section": "5.2. 차원과 축",
    "text": "5.2. 차원과 축\n\n5.2.1. 차원(dimension)\n\n넘파이 배열의 차원\n\n관측하고자 하는 데이터의 속성의 수 또는 측정 항목의 수\n스칼라(scalar) : 0차원 배열, 배열에서 값을 표현하는 가장 기본 단위로 하나의 실수를 저장할 수 있음\n벡터(vector) : 1차원 배열, 스칼라 여러 개를 나열한 배열\n행렬(matrix) : 2차원 배열, 1차원 배열을 여러 개 묶은 배열\n텐서(tensor) : 3차원 이상의 배열, 벡터의 집합\n\n\n\n\n\n\narr0 = np.array(3.14)                        # 0차원 배열(스칼라)\narr1 = np.array([3.14])                      # 1차원 배열(벡터)\narr2 = np.array([[3.14]])                    # 2차원 배열(행렬)\narr3 = np.array([[[3.14]]])                  # 3차원 배열(텐서)\n\nprint(arr0.ndim, arr0.shape)\nprint(arr1.ndim, arr1.shape)\nprint(arr2.ndim, arr2.shape)\nprint(arr3.ndim, arr3.shape)\n\n0 ()\n1 (1,)\n2 (1, 1)\n3 (1, 1, 1)\n\n\n\n# 1차원 배열(벡터)\narr = np.array([1, 2, 3])\nprint(arr.ndim)\nprint(arr.shape)\n\n1\n(3,)\n\n\n\n# 2차원 배열(행렬)\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr.ndim)\nprint(arr.shape)\n\n2\n(2, 3)\n\n\n\n# 3차원 배열(텐서)\narr = np.array([[[1, 2, 3], [4, 5, 6]], [[11, 12, 13], [14, 15, 16]]])\nprint(arr.ndim)\nprint(arr.shape)\n\n3\n(2, 2, 3)\n\n\n\n\n\n5.2.2. 축(axis)\n\n배열에서 데이터를 따라가는 방향\n\n차원이 있는 데이터에서 어느 방향으로 연산을 적용하는지 축으로 지정\n\naxis 0은 첫 번째 차원으로, 배열의 가장 바깥쪽 차원임\n\n차원이 늘어날수록 새로운 축이 axis=0가 되며, 기존 축들은 번호가 하나씩 뒤로 밀림\n\n축 번호는 배열의 차원에 따라 증가하며, 각 축은 shape에서 해당하는 차원의 크기를 나타냄\n\n(예) shape (2, 3, 4) → axis 0: 2(면), axis 1: 3(행), axis 2: 4(열)\n\n\n\n\n\n\n\n\n\n\n\n\n\n차원\n직관적인 구조\n축의 역할\n\n\n\n\n1차원\n벡터 → [1, 2, 3, 4]\naxis 0: 왼쪽 → 오른쪽\n\n\n2차원\n벡터들이 위아래로 쌓임 → 행렬\naxis 0: 위 → 아래(행) axis 1: 왼쪽 → 오른쪽(열)\n\n\n3차원\n행렬들이 앞뒤로 쌓임\naxis 0: 앞 → 뒤(면) axis 1: 위 → 아래(행) axis 2: 왼쪽 → 오른쪽(열)\n\n\n\n\n\n\n\n5.2.3. 넘파이 배열 메소드\n\n\n\n함수\n설명\n\n\n\n\nsum()\n합계\n\n\nmean()\n평균\n\n\nstd()\n표준편차\n\n\nmin(), max()\n최소값, 최대값\n\n\ncumsum(), cumprod()\n누적 합계, 누적 곱\n\n\ntranspose()\n축 순서 변경\n\n\n\n\n\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\n# 합계\nprint(np.sum(arr))\nprint(np.sum(arr, axis=0))\nprint(np.sum(arr, axis=1))\n\n21\n[5 7 9]\n[ 6 15]\n\n\n\n# 누적합\nprint(np.cumsum(arr))\nprint(np.cumsum(arr, axis=0))\nprint(np.cumsum(arr, axis=1))\n\n[ 1  3  6 10 15 21]\n[[1 2 3]\n [5 7 9]]\n[[ 1  3  6]\n [ 4  9 15]]\n\n\n\n\n\n5.2.4. 배열 형태 변환\n\n\n\n함수\n설명\n\n\n\n\nreshape()\n배열을 데이터 변경없이 새로운 모양으로 변환\n\n\nflatten()\n다차원 배열을 1차원 배열로 복사하여 반환(원본 유지)\n\n\nravel()\n다차원 배열을 1차원 배열로 반환(가능하면 원본 공유, 더 효율적)\n\n\n\n\n\n# 1차원 배열 → 2차원 배열(3행 2열)\narr = np.array([1, 2, 3, 4, 5, 6])\n\nprint(arr.reshape(3, 2))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[[1 2]\n [3 4]\n [5 6]]\n[1 2 3 4 5 6]\n\n\n\n# 1차원 배열 → 3차원 배열\narr = np.arange(24)\n\nprint(arr.reshape(2, 3, 4))\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[[[ 0  1  2  3]\n  [ 4  5  6  7]\n  [ 8  9 10 11]]\n\n [[12 13 14 15]\n  [16 17 18 19]\n  [20 21 22 23]]]\n[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23]\n\n\n\n# 2차원 배열 → 1차원 배열 (복사본 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.flatten())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n\n\n\n# 2차원 배열 → 1차원 배열 (가능하면 뷰 반환)\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.ravel())\nprint(arr)                                 # arr 원본 값이 변하지 않음\n\n[1 2 3 4 5 6]\n[[1 2 3]\n [4 5 6]]\n\n\n\n\n\n5.2.5. 축 재배열\n\n\n\n함수\n설명\n\n\n\n\ntranspose()\n배열의 축 순서 변환(2차원 배열의 경우 행/열 전치)\n\n\nswaqaxes()\n지정한 두 축의 순서를 교환\n\n\n\n\n\n# 2차원 배열에서 transpose()\narr = np.array([\n    [1, 2, 3],\n    [4, 5, 6]\n])\n\nprint(arr.transpose())\n\n[[1 4]\n [2 5]\n [3 6]]\n\n\n\n# 3차원 배열에서 transpose()\narr = np.arange(24).reshape(2, 3, 4)\n\n# 축 순서 바꾸기 : (0, 1, 2) → (1, 0, 2)\nprint(arr.transpose(1, 0, 2))\nprint(arr.transpose(1, 0, 2).shape)\n\n[[[ 0  1  2  3]\n  [12 13 14 15]]\n\n [[ 4  5  6  7]\n  [16 17 18 19]]\n\n [[ 8  9 10 11]\n  [20 21 22 23]]]\n(3, 2, 4)\n\n\n\n# 3차원 배열에서 axis 0과 axis 2 교환\narr = np.array([\n    [[1, 2], [3, 4]],\n    [[5, 6], [7, 8]]\n])\n\nprint(np.swapaxes(arr, 0, 2))\nprint(np.swapaxes(arr, 0, 2).shape)\n\n[[[1 5]\n  [3 7]]\n\n [[2 6]\n  [4 8]]]\n(2, 2, 2)"
  },
  {
    "objectID": "5_numpy.html#얕은-복사와-깊은-복사",
    "href": "5_numpy.html#얕은-복사와-깊은-복사",
    "title": "\n\nNumPy\n",
    "section": "5.3. 얕은 복사와 깊은 복사",
    "text": "5.3. 얕은 복사와 깊은 복사\n\n얕은 복사(shallow copy)\n\n데이터의 주소를 복사하여 원본과 메모리 공간을 공유\n원본을 수정하면 복사본이 바뀌며, 반대로 복사본을 수정해도 원본에 영향을 미침\nview(), reshape() (대부분), ravel() (대부분)\n\n\n\n\n깊은 복사(deep copy)\n\n완전히 새로운 메모리 공간에 데이터의 복사본을 생성\n원본을 수정해도 복사본이 바뀌지 않으며, 반대로 복사본을 수정해도 원본에 영향을 주지 않음\ncopy(), flatten()\n\n\n\n\n# 얕은 복사\narr = np.arange(6)\nprint(arr)\n\ncopy_arr = arr.view()\nprint(copy_arr)\n\ncopy_arr[0] = 10\nprint(arr)\nprint(copy_arr)\n\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n[10  1  2  3  4  5]\n[10  1  2  3  4  5]\n\n\n\n# 깊은 복사\narr = np.arange(6)\nprint(arr)\n\ncopy_arr = arr.copy()\nprint(copy_arr)\n\ncopy_arr[0] = 10\nprint(arr)\nprint(copy_arr)\n\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n[0 1 2 3 4 5]\n[10  1  2  3  4  5]"
  },
  {
    "objectID": "5_numpy.html#인덱싱과-슬라이싱",
    "href": "5_numpy.html#인덱싱과-슬라이싱",
    "title": "\n\nNumPy\n",
    "section": "5.4. 인덱싱과 슬라이싱",
    "text": "5.4. 인덱싱과 슬라이싱\n\n인덱싱(indexing)\n\n[index]를 사용하여 배열의 특정 위치에 있는 원소에 접근함\n얕은 복사(shallow copy)로 작동 → 원본과 메모리 공간을 공유\n팬시 인덱싱(fancy indexing)\n\n배열이나 리스트를 인덱스로 사용하여 원하는 위치의 값들을 한 번에 추출\n복사본을 반환(deep copy) → 원본과 메모리 공간을 공유하지 않음\n\n불리언 인덱싱(boolean indexing)\n\n조건식을 통해 bool형 배열을 생성하여 True인 원소만 추출\n복사본을 반환(deep copy) → 원본과 메모리 공간을 공유하지 않음\n\n\n\n\n\n슬라이싱(slicing)\n\n[(start index):(stop index)]를 사용하여 배열의 일부 원소를 추출함\n얕은 복사(shallow copy)로 작동하며 뷰(view)를 반환 → 원본과 메모리 공간을 공유\n\n\n\n\n# 1차원 인덱싱과 슬라이싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[0])\nprint(arr[-1])\nprint(arr[1:4])\nprint(arr[::2])\n\n10\n50\n[20 30 40]\n[10 30 50]\n\n\n\n# 슬라이싱은 기본적으로 뷰(view)임\narr = np.array([10, 20, 30, 40, 50])\nprint(arr)\n\nsub_arr = arr[1:4]\nprint(sub_arr)\n\nsub_arr[0] = 100\nprint(arr)\nprint(sub_arr)\n\n[10 20 30 40 50]\n[20 30 40]\n[ 10 100  30  40  50]\n[100  30  40]\n\n\n\n# copy() 함수를 이용해서 깊은 복사를 해야 원본이 변하지 않음\narr = np.array([10, 20, 30, 40, 50])\nprint(arr)\n\nsub_arr = arr[1:4].copy()\nprint(sub_arr)\n\nsub_arr[0] = 100\nprint(arr)\nprint(sub_arr)\n\n[10 20 30 40 50]\n[20 30 40]\n[10 20 30 40 50]\n[100  30  40]\n\n\n\n# 2차원 인덱싱과 슬라이싱\narr = np.array([[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]])\nprint(arr[1, 2])                           # arr[1][2], 리스트에서는 안 됨\nprint(arr[0:2, 1:3])\nprint(arr[0])                              # 첫 번째 행의 모든 열\nprint(arr[:, 1])                           # 모든 행의 두 번째 열\nprint(arr[1:, :2])                         # 두 번째 행부터 끝까지, 처음부터 두 번째 열까지\n\n6\n[[2 3]\n [5 6]]\n[1 2 3]\n[2 5 8]\n[[4 5]\n [7 8]]\n\n\n\n# 3차원 인덱싱과 슬라이싱\narr = np.arange(24).reshape(2, 3, 4)\n\nprint(arr[1, 2])                           # arr[1][2], 리스트에서는 안 됨\nprint(arr[1, 2, 3])                        # 두 번째 면, 세 번째 행, 네 번째 열\nprint(arr[:, 1, :])                        # 모든 면의 두 번째 행 → shape(2, 4)\n\n[20 21 22 23]\n23\n[[ 4  5  6  7]\n [16 17 18 19]]\n\n\n\n# 팬시 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[[0, 3, 4]])\n\n[10 40 50]\n\n\n\n# 불리언 인덱싱\narr = np.array([10, 20, 30, 40, 50])\nprint(arr &gt; 30)\nprint(arr[arr &gt; 30])\n\n[False False False  True  True]\n[40 50]"
  },
  {
    "objectID": "5_numpy.html#넘파이-배열-연산",
    "href": "5_numpy.html#넘파이-배열-연산",
    "title": "\n\nNumPy\n",
    "section": "5.5. 넘파이 배열 연산",
    "text": "5.5. 넘파이 배열 연산\n\n벡터화(vectorization)\n\n반복문을 사용하지 않고 배열 전체에 연산을 적용하는 기능\n동일한 shape을 가진 배열 간에 같은 인덱스에 위치한 원소들끼리(element-wise) 연산을 수행함\n\n두 배열의 shape가 다르더라도 브로드캐스팅이 가능한 경우에는 연산이 가능함\n\n이 경우 내부적으로 브로드캐스팅을 통해 shape를 맞춘 후, 벡터화 연산을 수행함\n\n\n\n\n\n브로드캐스팅(broadcasting)\n\n차원이 서로 다른 배열 간의 연산을 자동으로 처리해주는 기능\n더 작은 차원인 배열의 shape를 자동으로 확장하여 연산이 가능하도록 함\n브로드캐스팅이 적용되는 조건\n\n차원이 다르면, 더 작은 배열 앞쪽(왼쪽)에 1을 추가해서 맞춰줌\n차원이 같으면, 각 차원의 크기를 비교하여 두 값이 같거나 한 쪽이 1이면 브로드캐스팅 가능함\n\n\n\n\n\n\n\n# 벡터화\narr1 = np.array([1, 2, 3])\narr2 = np.array([10, 20, 30])\n\nprint(arr1 + arr2)\nprint(arr1 / arr2)\n\n[11 22 33]\n[0.1 0.1 0.1]\n\n\n\n# 브로드캐스팅1 : 1차원 + 스칼라\narr = np.array([1, 2, 3])\nprint(arr + 10)\n\n[11 12 13]\n\n\n\n# 브로드캐스팅2 : 차원 수가 다른 경우\narr1 = np.array([[1], [2], [3]])           # shape : (3, 1)\narr2 = np.array([10, 20, 30, 40])          # shape : (4,) → (1, 4)로 간주\n\nprint(arr1.shape, arr2.shape)\nprint(arr1 + arr2)                \n\n(3, 1) (4,)\n[[11 21 31 41]\n [12 22 32 42]\n [13 23 33 43]]\n\n\n\n# 브로드캐스팅3 : 두 배열의 열 크기가 다르므로 브로드캐스팅 불가능\n#arr1 = np.array([[1, 2, 3],\n#                 [4, 5, 6]])               # shape : (2, 3)\n#arr2 = np.array([10, 20, 30, 40])          # shape: (4,) → (1, 4)로 간주\n#\n#print(arr1.shape, arr2.shape)\n#print(arr1 + arr2)\n\n\n# 브로드캐스팅 : 3차원 + 1차원\narr1 = np.arange(24).reshape(2, 3, 4)      # shape : (2, 3, 4)\narr2 = np.array([10, 20, 30, 40])          # shape : (4,) → (1, 1, 4)로 간주\n\nprint(arr1.shape, arr2.shape)\nprint((arr1 + arr2).shape)                 # shaep : (2, 3, 4)\nprint(arr1 + arr2)\n\n(2, 3, 4) (4,)\n(2, 3, 4)\n[[[10 21 32 43]\n  [14 25 36 47]\n  [18 29 40 51]]\n\n [[22 33 44 55]\n  [26 37 48 59]\n  [30 41 52 63]]]"
  },
  {
    "objectID": "3_structure.html",
    "href": "3_structure.html",
    "title": "\n\n자료구조\n",
    "section": "",
    "text": "자료구조"
  },
  {
    "objectID": "3_structure.html#자료구조",
    "href": "3_structure.html#자료구조",
    "title": "\n\n자료구조\n",
    "section": "3.1. 자료구조",
    "text": "3.1. 자료구조\n\n3.1.1. 자료구조의 중요성\n\n자료구조(data structure)\n\n데이터를 효율적으로 저장하고 접근하기 위한 구조적 방식\n\n\n\n\n자료구조의 중요성\n\n데이터 저장과 검색 효율화 : (예) 빠른 검색이 필요한 경우 딕셔너리 사용\n연산 속도 최적화 : (예) 중복을 제거하는 경우 리스트보다 세트가 효율적임\n메모리 사용 절약 : (예) 불변형 객체를 다룰 때는 리스트 대신 튜플 사용\n코드 가독성 및 유지보수성 향상\n\n\n\n\n\n3.1.2. Python 자료구조\n\n대표적인 자료구조에는 리스트(list), 튜플(tuple), 세트(set), 딕셔너리(dictionary)가 있음\n\n\n\n\n\n\n\n\n자료구조\n설명\n\n\n\n\n리스트(list)\n여러 개의 값을 저장할 수 있는 순차적인 자료구조\n\n\n튜플(tuple)\n리스트와 같지만 데이터의 변경을 허용하지 않는 자료구조\n\n\n세트(set)\n데이터의 중복을 허용하지 않고, 수학의 집합 연산을 지원하는 자료구조\n\n\n딕셔너리(dictionary)\n키(key)와 값(value)의 형태로 데이터를 저장하는 자료구조\n\n\n\n\n\n자료구조 비교\n\n\n\n\n자료구조\n순서 유지\n변경 가능\n중복 허용\n특징\n\n\n\n\n리스트(list)\n○\n○\n○\n가장 기본적인 자료구조, 인덱스로 접근\n\n\n튜플(tuple)\n○\n×\n○\n리스트와 유사하지만 불변형(immutable)\n\n\n세트(set)\n×\n○\n×\n중복 제거, 수학적 집합 연산 가능\n\n\n딕셔너리(dictionary)\n○\n○\n△\n키-값(key-value) 형태로 저장"
  },
  {
    "objectID": "3_structure.html#리스트",
    "href": "3_structure.html#리스트",
    "title": "\n\n자료구조\n",
    "section": "3.2. 리스트",
    "text": "3.2. 리스트\n\n3.2.1. 리스트 생성\n\n리스트(list)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 존재하는 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n정수, 부동소수점수, 문자열, bool, 리스트, 튜플, 딕셔너리 등 다양한 자료형을 저장할 수 있는 컨테이너형 객체\n\n\n\n\n리스트 생성\n\n리터럴 방식(list literal)\n\n[] 사용하여 리스트를 직접 정의하는 방법\n[] 안에 원소(element)를 ,로 구분하여 나열함\n\n생성자 방식(list constructor)\n\nlist() 함수를 사용하여 리스트를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)을 인수로 받아 리스트를 생성할 때 유용함\n\n\n\n\n\n# 리스트 생성1\nlst = [1, 2, 3, 4, 5]\nprint(lst)\n\n[1, 2, 3, 4, 5]\n\n\n\n# 리스트 생성2\nlst = list([1, 2, 3, 4, 5])\nprint(lst)\n\n[1, 2, 3, 4, 5]\n\n\n\n# 리스트 생성3 : 리스트는 다양한 자료형을 저장할 수 있음\nlst = [1, 3.14, \"Hello\", True, [11, 12, 13]]\nprint(lst)\n\n[1, 3.14, 'Hello', True, [11, 12, 13]]\n\n\n\n# 리스트 생성4 : iterable 객체 사용\nlst = list(\"Hello\")\nprint(lst)\n\n['H', 'e', 'l', 'l', 'o']\n\n\n\n# 리스트 생성5 : iterable 객체 사용\nlst = list(range(10))\nprint(lst)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n\n\n3.2.2. 리스트 연산\n\n리스트 연결 연산자 + : 두 리스트를 연결해서 새로운 리스트 생성\n리스트 반복 연산자 * : 리스트를 숫자만큼 반복하여 새로운 리스트 생성 - (예) 리스트*숫자\n\n\n\n# 리스트 연결\nlst1 = [1, 2, 3]\nlst2 = [11, 12, 13]\nprint(lst1 + lst2)\n\n[1, 2, 3, 11, 12, 13]\n\n\n\n# 리스트 반복\nprint(lst1 * 3)\n\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n\n\n\n\n\n3.2.3. 인덱싱과 슬라이싱\n\n인덱싱(indexing) : [index]를 사용하여 리스트의 특정 위치에 있는 원소에 접근함\n슬라이싱(slicing) : [(start index):(stop index)]를 사용하여 리스트의 일부 원소를 추출함\n\nlist[(start index):(end index)] = iterable를 사용하면 start:end로 지정한 부분이 iterable 객체의 모든 원소로 대체됨\n슬라이싱을 이용하여 기존 리스트의 일부를 삭제하거나, 새로운 원소를 추가 및 변경할 수 있음\n\n\n\n\n\n\n# 리스트 인덱싱1\nlst = [10, 20, 30, 40, 50]\nprint(lst[0])\n\n10\n\n\n\n# 리스트 인덱싱2\nlst = [10, 20, 30, 40, 50]\nprint(lst[-1])\n\n50\n\n\n\n# 리스트 접근 연산자 []를 이중으로 사용할 수 있음\nlst = [1, 3.14, \"Hello\", True, [11, 12, 13]]\nprint(lst[2])\nprint(lst[2][0])\n\nHello\nH\n\n\n\n# 리스트 슬라이싱1\nlst = [10, 20, 30, 40, 50]\nprint(lst[0:2])\n\n[10, 20]\n\n\n\n# 리스트 슬라이싱2\nlst = [10, 20, 30, 40, 50]\nprint(lst[:2])\nprint(lst[2:])\nprint(lst[::2])\n\n[10, 20]\n[30, 40, 50]\n[10, 30, 50]\n\n\n\n# 리스트는 가변형 객체이므로 인덱스를 이용한 수정이 가능함\nlst = [10, 20, 30, 40, 50]\nlst[2] = 3\nprint(lst)\n\n[10, 20, 3, 40, 50]\n\n\n\n# 슬라이싱을 이용한 원소 삭제\nlst = [10, 20, 30, 40, 50]\nlst[1:4] = []                              # 빈 리스트를 할당하면 해당 부분이 삭제됨\nprint(lst)\n\n[10, 50]\n\n\n\n# 슬라이싱을 이용한 원소 추가\nlst = [10, 20, 30, 40, 50]\nlst[1:1] = [6, 7]                          # 인덱스 1 위치에 [6, 7]의 원소를 개별적으로 추가\nprint(lst)\n\n[10, 6, 7, 20, 30, 40, 50]\n\n\n\n# 슬라이싱을 이용한 원소 수정\nlst = [10, 20, 30, 40, 50]\nlst[1:3] = [6, 7, 8]                       # 인덱스 1~2 부분을 [6, 7, 8]로 수정\nprint(lst)\n\n[10, 6, 7, 8, 40, 50]\n\n\n\n\n\n3.2.4. 중첩 리스트\n\n리스트 안에 또 다른 리스트가 포함된 구조\n2차원 리스트\n\n모든 내부 리스트가 동일한 길이를 가진 경우\n일반적으로 행(row)과 열(column)로 이루어짐\n행렬(matrix)처럼 활용하거나, 데이터를 일정한 구조로 관리할 때 유용함\n\n\n\n\n# 중첩 리스트\nnested_lst = [\n    [1, 2, 3],\n    [4, 5, 6, 7],\n    [8, 9]\n]\n\nprint(nested_lst)\n\n[[1, 2, 3], [4, 5, 6, 7], [8, 9]]\n\n\n\nfor items in nested_lst:\n    for item in items:\n        print(item)\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 2차원 리스트\nkor = [80, 82, 75, 95]\neng = [67, 95, 84, 83]\nmath = [74, 88, 82, 76]\nmidterm = [kor, eng, math]\nprint(midterm)\n\n[[80, 82, 75, 95], [67, 95, 84, 83], [74, 88, 82, 76]]\n\n\n\n# 2차원 리스트 인덱싱\nmidterm[0][3]\n\n95\n\n\n\n\n\n3.2.5. 리스트 메소드\n\n3.2.5.1. 리스트 추가\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nappend()\n- 새로운 값을 기존 리스트의 맨 끝에 추가\n\n\nextend()\n- 새로운 리스트를 기존 리스트에 추가(덧셈 연산과 같은 효과)\n\n\ninsert()\n- 기존 리스트의 i번째 인덱스에 새로운 값을 추가 - i번째 인덱스를 기준으로 뒤쪽의 인덱스는 하나씩 밀림\n\n\n\n\n\n# 리스트에 한 개의 원소 추가1\nlst = [1, 2, 3]\nlst.append(4)                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 4]\n\n\n\n# 리스트에 한 개의 원소 추가2\n# 원본 값 변화 없이 리스트에 한 개의 원소를 추가하려면 전개 연산자 *를 사용하면 됨\nlst = [1, 2, 3]\nnew_lst = [*lst, 4]\nprint(lst)                                 # lst 원본 값이 변하지 않음\nprint(new_lst)\n\n[1, 2, 3]\n[1, 2, 3, 4]\n\n\n\n# append() 함수는 여러 개의 인수를 입력하거나, 연속으로 사용할 수 없음\nlst = [1, 2, 3]\n#lst.append(4,5)\n#lst.append(4).append(5)\n\n\n# 리스트에 여러 개의 원소 추가\nlst = [1, 2, 3]\nlst.extend([11, 12])                       # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst1 원본 값이 변함\n\n[1, 2, 3, 11, 12]\n\n\n\n# extend() 함수와 리스트 연결 연산자 +의 차이\nlst1 = [1, 2, 3]\nlst2 = [11, 12, 13]\nlst1 + lst2                                # 실행 결과가 출력됨\nprint(lst1)                                # lst1 원본 값이 변하지 않음\nprint(lst2)                                # lst2 원본 값이 변하지 않음\n\n[1, 2, 3]\n[11, 12, 13]\n\n\n\n# 특정 위치에 한 개의 원소 추가\nlst = [1, 2, 3]\nlst.insert(0, 100)                         # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[100, 1, 2, 3]\n\n\n\n# 특정 위치에 여러 개의 원소 추가 : 슬라이싱을 이용\nlst = [1, 2, 3]\nlst[1:1] = [11, 12]                        # 인덱스 1의 위치에 리스트 [11, 12]의 원소를 개별적으로 삽입\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 11, 12, 2, 3]\n\n\n\n\n\n3.2.5.2. 리스트 삭제\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\npop()\n- 특정 인덱스 값을 삭제하고 그 값을 반환 - 인덱스를 생략하면 마지막 원소를 삭제\n\n\ndel 키워드\n- 특정 인덱스 값을 삭제 - 리스트 객체 자체를 삭제 가능함\n\n\nremove()\n- 리스트에서 첫 번째로 일치하는 값을 삭제 - 값으로 삭제하므로 인덱스를 사용하지 않음\n\n\nclear()\n- 리스트의 모든 원소를 삭제\n\n\n\n\n\n# 특정 인덱스 값 삭제1\nlst = [1, 2, 3, 4, 5]\nresult = lst.pop(3)                        # 실행 결과로 삭제한 값을 반환\nprint(lst)                                 # lst 원본 값이 변함\nprint(result)\n\n[1, 2, 3, 5]\n4\n\n\n\n# 특정 인덱스 값 삭제2\nlst = [1, 2, 3, 4, 5]\nresult = lst.pop()                         # 인덱스를 생략하면 마지막 원소를 삭제 후 반환\nprint(lst)                                 # lst 원본 값이 변함\nprint(result)\n\n[1, 2, 3, 4]\n5\n\n\n\n# 특정 인덱스 값 삭제3\nlst = [1, 2, 3, 4, 5]\ndel lst[3]                                 # 실행 결과로 아무것도 반환하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 5]\n\n\n\n# 리스트 객체 삭제\nlst = [1, 2, 3, 4, 5]\ndel lst\n#print(lst)\n\n\n# 일치하는 값 삭제1\nlst = [1, 2, 3, 4, 5]\nlst.remove(4)                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 2, 3, 5]\n\n\n\n# 일치하는 값 삭제2\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nlst.remove(1)                              # 첫 번째로 일치하는 값만 삭제됨\nprint(lst)                                 # lst 원본 값이 변함\n\n[2, 3, 1, 4, 5, 1, 6, 7]\n\n\n\n# 리스트 모든 원소 삭제\nlst = [1, 2, 3, 4, 5]\nlst.clear()                                # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[]\n\n\n\n\n\n3.2.5.3. 리스트 재배열\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nreverse()\n- 리스트 원소를 역순으로 재배열\n\n\nsort()\n- 리스트 원소를 오름차순(default)으로 정렬 - 내림차순으로 정렬하려면 reverse=True로 설정\n\n\n\n\n\n# 리스트 역순 재배열\nlst = [52, 273, 103, 32, 275, 1, 7]\nlst.reverse()                              # 실행 결과로 아무것도 출력하지 않음\nprint(lst)                                 # lst 원본 값이 변함\n\n[7, 1, 275, 32, 103, 273, 52]\n\n\n\n# 리스트 정렬\nlst = [52, 273, 103, 32, 275, 1, 7]\nlst.sort()                                 # 실행 결과로 아무것도 출력하지 않음, 오름차순 정렬\nprint(lst)                                 # lst 원본 값이 변함\n\nlst.sort(reverse=True)                     # 내림차순 정렬\nprint(lst)                                 # lst 원본 값이 변함\n\n[1, 7, 32, 52, 103, 273, 275]\n[275, 273, 103, 52, 32, 7, 1]\n\n\n\n\n\n3.2.5.4. 리스트 검색\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\n리스트 내부에 특정 값이 몇 번 나타나는지 개수를 반환\n\n\nindex()\n리스트 내부에 특정 값의 첫 번째 인덱스를 반환하며, 없으면 오류 발생\n\n\nin 연산자\n리스트 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\n\n\n\n# 특정 값 개수\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nprint(lst.count(1))\nprint(lst.count(9))\n\n3\n0\n\n\n\n# 특정 값의 첫 번쩨 인덱스\nlst = [1, 2, 3, 1, 4, 5, 1, 6, 7]\nprint(lst.index(1))\n#print(lst.index(9))\n\n0\n\n\n\n# 특정 값 찾기\nlst = [1, 2, 3, 4, 5]\nprint(3 in lst)\nprint(6 in lst)\n\nTrue\nFalse\n\n\n\n\n\n3.2.5.5. 리스트 통계\n\n\n\n함수\n설명\n\n\n\n\nlen()\n리스트 원소의 개수(리스트 길이) 반환\n\n\nsum()\n리스트 원소의 합계 반환\n\n\nmax()\n리스트 원소 중 최대값 반환\n\n\nmin()\n리스트 원소 중 최소값 반환\n\n\n\n\n\nlst = [1, 2, 3, 4, 5]\nprint(len(lst))\nprint(sum(lst))\nprint(max(lst))\nprint(min(lst))\n\n5\n15\n5\n1\n\n\n\n\n\n\n3.2.6. 리스트 컴프리헨션\n\n[식 for 변수 in 반복범위 if 조건식]\n\n\n\n기존 리스트를 사용하여 간결하게 새로운 리스트를 생성하는 기법\n리스트와 for 문을 한 줄에 사용할 수 있어 코드가 더 직관적으로 작성됨\n필터링, 중첩 반복문, 이차원 리스트 등 다양한 방식으로 활용됨\n\n\n\n리스트 컴프리헨션은 수학에서 집합을 정의할 때 특정 조건을 만족하는 원소들의 집합으로 표현하는 방법과 유사함\n\n수학적 집합 : S = {x | x는 0 이상 10 이하의 정수}\n리스트 컴프리헨션 : [x for x in range(10)]\n\n\n\n\n## 0~9 정수 저장\n# 일반적인 반복문 + 리스트\nresult1 = []\nfor i in range(10):\n    result1.append(i)\n\nprint(result1)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n## 0~9 정수 저장\n# 리스트 컴프리헨션\nresult2 = [i for i in range(10)]\nprint(result2)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\n## 짝수만 저장 (필터링, if 문과 함께 사용)\n# 일반적인 반복문 + 리스트\nresult1 = []\nfor i in range(10):\n    if i % 2 == 0:\n        result1.append(i)\n\nprint(result1)\n\n[0, 2, 4, 6, 8]\n\n\n\n## 짝수만 저장 (필터링, if 문과 함께 사용)\n# 리스트 컴프리헨션\nresult2 = [i for i in range(10) if i % 2 == 0]\nprint(result2)\n\n[0, 2, 4, 6, 8]\n\n\n\n## 두 개의 문자열 조합하여 새로운 리스트 생성 (중첩 반복문)\n# 일반적인 반복문 + 리스트\nword1 = \"Hello\"\nword2 = \"World\"\nresult1 = []\n\nfor i in word1:\n    for j in word2:\n        result1.append(i+j)\n\nprint(result1)\n\n['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']\n\n\n\n## 두 개의 문자열 조합하여 새로운 리스트 생성 (중첩 반복문)\n# 리스트 컴프리헨션\nword1 = \"Hello\"\nword2 = \"World\"\n\nresult2 = [i+j for i in word1 for j in word2]\nprint(result2)\n\n['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']\n\n\n\n# 리스트 컴프리헨션 (필터링 + 중첩 반복문)\ncase1 = [\"A\", \"B\", \"C\"]\ncase2 = [\"D\", \"E\", \"A\"]\nresult = [i + j for i in case1 for j in case2 if not(i==j)]\nprint(result)\n\n['AD', 'AE', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA']\n\n\n\n## 리스트의 각 원소를 대문자, 소문자, 길이로 변환하여 이차원 리스트 생성 (이차원 리스트)\n# 일반적인 반복문 + 리스트\nwords = \"The quick brown fox jumps over the lazy dog\".split()\nword_info1 = []\n\nfor w in words:\n    word_info1.append([w.upper(), w.lower(), len(w)])\n\nword_info1\n\n[['THE', 'the', 3],\n ['QUICK', 'quick', 5],\n ['BROWN', 'brown', 5],\n ['FOX', 'fox', 3],\n ['JUMPS', 'jumps', 5],\n ['OVER', 'over', 4],\n ['THE', 'the', 3],\n ['LAZY', 'lazy', 4],\n ['DOG', 'dog', 3]]\n\n\n\n## 리스트의 각 원소를 대문자, 소문자, 길이로 변환하여 이차원 리스트 생성 (이차원 리스트)\n# 리스트 컴프리헨션\nwords = \"The quick brown fox jumps over the lazy dog\".split()\nword_info2 = [[w.upper(), w.lower(), len(w)] for w in words]\nword_info2\n\n[['THE', 'the', 3],\n ['QUICK', 'quick', 5],\n ['BROWN', 'brown', 5],\n ['FOX', 'fox', 3],\n ['JUMPS', 'jumps', 5],\n ['OVER', 'over', 4],\n ['THE', 'the', 3],\n ['LAZY', 'lazy', 4],\n ['DOG', 'dog', 3]]\n\n\n\n# [주의] 반복문에서 대괄호의 위치에 따라 리스트의 구조가 달라짐\ncase1 = [\"A\", \"B\", \"C\"]\ncase2 = [\"1\", \"2\", \"3\"]\n\n# 일차원 리스트, 앞의 for 문이 먼저 실행됨\nresult1 = [i + j for i in case1 for j in case2]\nprint(result1)\n\n# 이차원 리스트, 뒤의 for 문이 바깥쪽에서 먼저 실행됨\nresult2 = [[i + j for i in case1] for j in case2]\nprint(result2)\n\n['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3']\n[['A1', 'B1', 'C1'], ['A2', 'B2', 'C2'], ['A3', 'B3', 'C3']]"
  },
  {
    "objectID": "3_structure.html#튜플",
    "href": "3_structure.html#튜플",
    "title": "\n\n자료구조\n",
    "section": "3.3. 튜플",
    "text": "3.3. 튜플\n\n3.3.1. 튜플 생성\n\n튜플(tuple)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 존재하는 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에는 수정할 수 없는 불변형(immutable) 객체\n정수, 부동소수점수, 문자열, bool, 리스트, 튜플, 딕셔너리 등 다양한 자료형을 저장할 수 있는 컨테이너형 객체\n리스트와 구조 및 사용 방법이 거의 동일하지만, 수정이 불가능하다는 차이점이 있음\n\n\n\n\n튜플 생성\n\n리터럴 방식(tuple literal)\n\n()를 사용하여 튜플을 직접 정의하는 방법\n() 안에 원소(element)를 ,로 구분하여 나열함\n()을 생략할 수도 있지만, 원소가 하나인 경우에는 (값,)처럼 반드시 ,를 포함해야 함\n\n생성자 방식(tuple constructor)\n\ntuple() 함수를 사용하여 튜플을 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 튜플을 생성할 때 유용함\n\n\n\n\n\n# 튜플 생성1\ntpl = (1, 2, 3, 4, 5)\nprint(tpl)\n\n(1, 2, 3, 4, 5)\n\n\n\n# 튜플 생성2\ntpl = 1, 2, 3, 4, 5\nprint(tpl)\n\n(1, 2, 3, 4, 5)\n\n\n\n# 튜플 생성3 : 원소가 하나인 경우에는 반드시 ,를 포함해야 함\ntpl = (1,)\nprint(tpl)\n\n(1,)\n\n\n\n# 튜플 생성4 : 튜플은 다양한 자료형을 저장할 수 있음\ntpl = (1, 3.14, \"Hello\", True, [11, 12, 13], (21, 22))\nprint(tpl)\n\n(1, 3.14, 'Hello', True, [11, 12, 13], (21, 22))\n\n\n\n# 튜플 생성5 : iterable 객체 사용\ntpl = tuple(\"Hello\")\nprint(tpl)\n\n('H', 'e', 'l', 'l', 'o')\n\n\n\n# 튜플 생성6 : iterable 객체 사용\ntpl = tuple([1, 2, 3])\nprint(tpl)\n\n(1, 2, 3)\n\n\n\n\n\n3.3.2. 튜플 연산\n\n리스트 연산과 문법이 동일함\n튜플 연결 연산자 + : 두 튜플을 연결해서 새로운 튜플 생성\n튜플 반복 연산자 * : 튜플을 숫자만큼 반복하여 새로운 튜플 생성 - (예) 튜플*숫자\n\n\n\n# 튜플 연결\ntpl1 = 1, 2, 3\ntpl2 = 11, 12, 13\nprint(tpl1 + tpl2)\n\n(1, 2, 3, 11, 12, 13)\n\n\n\n# 튜플 반복\nprint(tpl1 * 3)\n\n(1, 2, 3, 1, 2, 3, 1, 2, 3)\n\n\n\n\n\n3.3.3. 인덱싱와 슬라이싱\n\n리스트와 문법이 동일함\n인덱싱(indexing) : [index]를 사용하여 튜플의 특정 위치에 있는 원소에 접근함\n슬라이싱(slicing) : [(start index):(stop index)]를 사용하여 튜플의 일부 원소를 추출함\n\n리스트와 달리 불변형 객체이므로 슬라이싱을 이용하여 기존 튜플의 일부를 삭제하거나, 새로운 원소를 추가 및 변경할 수 없음\n\n\n\n\n# 튜플 인덱싱1\ntpl = 1, 2, 3, 4, 5\nprint(tpl[0])\n\n1\n\n\n\n# 튜플 인덱싱2\ntpl = 1, 2, 3, 4, 5\nprint(tpl[-1])\n\n5\n\n\n\n# 튜플 슬라이싱1\ntpl = 1, 2, 3, 4, 5\nprint(tpl[0:2])\n\n(1, 2)\n\n\n\n# 튜플 슬라이싱2\ntpl = 1, 2, 3, 4, 5\nprint(tpl[:2])\nprint(tpl[2:])\nprint(tpl[::2])\n\n(1, 2)\n(3, 4, 5)\n(1, 3, 5)\n\n\n\n# 튜플은 불변형 객체이므로 인덱스를 이용한 수정이 불가능함\n#tpl = 1, 2, 3, 4, 5\n#tpl[2] = 3\n#print(tpl)\n\n\n\n\n3.3.4. 튜플 메소드\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\n튜플 내부에 특정 값이 몇 번 나타나는지 개수를 반환\n\n\nindex()\n튜플 내부에 특정 값의 첫 번째 인덱스를 반환하며, 없으면 오류 발생\n\n\nin 연산자\n튜플 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\nlen()\n튜플 원소의 개수(튜플 길이) 반환\n\n\nsum()\n튜플 원소의 합계 반환\n\n\nmax()\n튜플 원소 중 최대값 반환\n\n\nmin()\n튜플 원소 중 최소값 반환\n\n\n\n\n\n# 특정 값 개수\ntpl = 1, 2, 3, 1, 4, 5, 1, 6, 7\nprint(tpl.count(1))\nprint(tpl.count(9))\n\n3\n0\n\n\n\n# 특정 값의 첫 번쩨 인덱스\ntpl = 1, 2, 3, 1, 4, 5, 1, 6, 7\nprint(tpl.index(1))\n#print(tpl.index(9))\n\n0\n\n\n\n# 특정값 찾기\ntpl = 1, 2, 3, 4, 5\nprint(3 in tpl)\nprint(6 in tpl)\n\nTrue\nFalse\n\n\n\ntpl = 1, 2, 3, 4, 5\nprint(len(tpl))\nprint(sum(tpl))\nprint(max(tpl))\nprint(min(tpl))\n\n5\n15\n5\n1"
  },
  {
    "objectID": "3_structure.html#세트",
    "href": "3_structure.html#세트",
    "title": "\n\n자료구조\n",
    "section": "3.4. 세트",
    "text": "3.4. 세트\n\n3.4.1. 세트 생성\n\n세트(set)\n\n여러 개의 값을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 없는 집합 자료형(set data type)\n중복을 허용하지 않으며, 순서가 유지되지 않음\n\n리스트, 튜플과 달리 인덱싱과 슬라이싱이 불가능함\n\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n정수, 부동소수점수, 문자열, bool, 튜플 등 해시 가능한(immutable) 자료형을 저장할 수 있는 컨테이너형 객체\n\n\n\n\n[참고] 해시(hash)\n\n데이터를 저장하거나 검색할 때 사용되는 고유한 숫자 값(해시 값)을 사용하는 과정\n세트와 딕셔너리는 내부적으로 해시 값을 사용하여 원소 또는 key에 빠르게 접근함(검색 속도가 빠름)\n해시 값은 변경되지 않아야 하므로, 불변형 객체만 사용할 수 있음\n\n\n\n\n세트 생성\n\n리터럴 방식(set literal)\n\n{}를 사용하여 세트를 직접 정의하는 방법\n{} 안에 원소(element)를 ,로 구분하여 나열함\n중복된 원소는 자동으로 제거됨\n\n생성자 방식(set constructor)\n\nset() 함수를 사용하여 세트를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 세트를 생성할 때 유용함\n빈 세트를 만들려면 반드시 set() 함수를 사용해야 함\n\n\n\n\n\n# 세트 생성1\nst = {1, 2, 3, 1, 1, 4}\nprint(st)\n\n{1, 2, 3, 4}\n\n\n\n# 세트 생성2\nst = set({1, 2, 3, 1, 1, 4})\nprint(st)\n\n{1, 2, 3, 4}\n\n\n\n# 세트 생성3 : 세트는 해시 가능한(immutable) 자료형을 저장할 수 있음\nst = {1, 3.14, \"Hello\", True, (1, 2, 3), \"Hello\", 1, 1, 1}\nprint(st)\n\n{1, 3.14, 'Hello', (1, 2, 3)}\n\n\n\n# 세트 생성4: iterable 객체 사용\nst = set(\"Hello\")\nprint(st)\n\n{'o', 'l', 'H', 'e'}\n\n\n\n# 세트 생성5 : iterable 객체 사용\nst1 = set([1, 2, 3, 1, 1, 4])\nst2 = set((1, 2, 3, 1, 1, 4))\nprint(st1)\nprint(st2)\n\n{1, 2, 3, 4}\n{1, 2, 3, 4}\n\n\n\n\n\n3.4.2. 세트 집합 연산 및 메소드\n\n\n\n연산\n연산자\n함수\n\n\n\n\n합집합\n|\nunion()\n\n\n교집합\n&\nintersection()\n\n\n차집합\n-\ndifference()\n\n\n대칭차집합\n^\nsymmetric_difference()\n\n\n부분집합 여부\n&lt;=\nissubset()\n\n\n\n\n\n\n\n# 세트 연산1\nA = {1, 2, 3}\nB = {3, 4, 5}\n\nprint(A | B)                               # 합집합\nprint(A & B)                               # 교집합\nprint(A - B)                               # 차집합\nprint(A ^ B)                               # 대칭차집합\nprint(A &lt;= B)                              # 부분집합 여부\n\n{1, 2, 3, 4, 5}\n{3}\n{1, 2}\n{1, 2, 4, 5}\nFalse\n\n\n\n# 세트 연산2\nA = {1, 2, 3}\nB = {3, 4, 5}\n\nprint(A.union(B))\nprint(A.intersection(B))\nprint(A.difference(B))\nprint(A.symmetric_difference(B))\nprint(A.issubset(B))\n\n{1, 2, 3, 4, 5}\n{3}\n{1, 2}\n{1, 2, 4, 5}\nFalse\n\n\n\n# 세트 연산3 : 여러 개의 세트를 연쇄적으로 한 번에 연산 가능\nA = {1, 2, 3}\nB = {3, 4, 5}\nC = {5, 6, 7}\n\n# 연산자 사용\nprint(A | B | C)\nprint(A & B & C)\n\n# 메소드 사용\nprint(A.union(B, C))\nprint(A.intersection(B, C))\n\n{1, 2, 3, 4, 5, 6, 7}\nset()\n{1, 2, 3, 4, 5, 6, 7}\nset()\n\n\n\n\n3.4.2.3. 세트 추가/삭제/검색\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nadd()\n- 새로운 값을 세트에 추가\n\n\nupdate()\n- 여러 개 값을 세트에 추가\n\n\npop()\n- 임의의 값을 삭제하고 그 값을 반환 - 어떤 값을 삭제할지 예측 불가능\n\n\nremove()\n- 세트에서 일치하는 값을 삭제 - 일치하는 값이 없으면 오류가 발생함\n\n\ndiscard()\n- 세트에서 일치하는 값을 삭제 - 일치하는 값이 없어도 오류가 발생하지 않음\n\n\nclear()\n- 세트의 모든 원소를 삭제\n\n\nin 연산자\n세트 내부에 특정 값이 있다면 True, 없다면 False를 반환\n\n\n\n\n\n# 세트에 한 개의 원소 추가\nst = {1, 2, 3}\nst.add(6)                                  # 실행 결과로 아무것도 출력하지 않음\nprint(st)                                  # st 원본 값이 변함\n\n{1, 2, 3, 6}\n\n\n\n# 세트에 여러 개의 원소 추가\nst = {1, 2, 3}\nst.update([1, 2, 6])                       # 리스트 사용\nprint(st)\n\nst.update((1, 7))                          # 튜플 사용\nprint(st)\n\nst.update({8, 9})                          # 세트 사용\nprint(st)\n\n{1, 2, 3, 6}\n{1, 2, 3, 6, 7}\n{1, 2, 3, 6, 7, 8, 9}\n\n\n\n# 임의의 원소 삭제\nst = {1, 2, 3}\nresult = st.pop()                          # 임의의 원소를 삭제 후 반환\nprint(st)                                  # st 원본 값이 변함\nprint(result)\n\n{2, 3}\n1\n\n\n\n# 일치하는 값 삭제1\nst = {1, 2, 3}\nst.remove(3)\nprint(st)\n\n{1, 2}\n\n\n\n# 일치하는 값 삭제2 : remove() 함수는 일치하는 값이 없으면 오류가 발생함\n#st = {1, 2, 3}\n#st.remove(4)\n#print(st)\n\n\n# 일치하는 값 삭제3\nst = {1, 2, 3}\nst.discard(3)\nprint(st)\n\n{1, 2}\n\n\n\n# 일치하는 값 삭제4 : discard() 함수는 일치하는 값이 없어도 오류가 발생하지 않음\nst = {1, 2, 3}\nst.discard(4)\nprint(st)\n\n{1, 2, 3}\n\n\n\n# 세트 모든 원소 삭제\nst = {1, 2, 3}\nst.clear()\nprint(st)\n\nset()\n\n\n\n# 특정값 찾기\nst = {1, 2, 3}\nprint(3 in st)\nprint(6 in st)\n\nTrue\nFalse"
  },
  {
    "objectID": "3_structure.html#딕셔너리",
    "href": "3_structure.html#딕셔너리",
    "title": "\n\n자료구조\n",
    "section": "3.5. 딕셔너리",
    "text": "3.5. 딕셔너리\n\n3.5.1. 딕셔너리 생성\n\n딕셔너리(dictionary)\n\n여러 개의 키-값(key-value) 쌍을 저장할 수 있는 컬렉션 자료형(collection data type)\n순서가 있는 매핑 자료형(mapping data type)(Python 3.7+)\n키(key)를 통해 값(value)을 찾는 구조\n\n키는 중복될 수 없고(해시 가능한 자료형만 가능), 값은 중복 가능함(모든 자료형 가능)\n\n한 번 생성된 이후에도 수정할 수 있는 가변형(mutable) 객체\n\n\n\n\n딕셔너리 생성\n\n리터럴 방식(dictionary literal)\n\n{key: value}를 사용하여 딕셔너리를 직접 정의하는 방법\n{} 안에 여러 개의 key: value 쌍을 ,로 구분하여 나열함\n중복된 키가 있으면 마지막에 정의한 값이 적용됨\n\n생성자 방식(dictionary constructor)\n\ndict() 함수를 사용하여 딕셔너리를 생성하는 방법\n다른 iterable 객체(리스트, 튜플, 세트, 딕셔너리, 문자열 등)를 인수로 받아 딕셔너리를 생성할 때 유용함\n\nzip() 함수를 이용하여 여러 개의 리스트나 튜플을 병렬로 묶어 키-값 쌍의 형태로 구성할 수 있음\nenumerate() 함수를 이용하여 인덱스를 키로, 원소를 값으로 하여 쌍으로 묶어 딕셔너리를 생성할 수 있음\n\n\n\n\n\n\n# 딕셔너리 생성1\ndct = {'a': 1, 'b': 2, 'c': 3}\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 생성2\ndct = dict(a=1, b=2, c=3)\nprint(dct)\n\n{'a': 1, 'b': 2, 'c': 3}\n\n\n\n# 딕셔너리 생성3 : 키는 중복될 수 없음\ndct = {'a':1, 'b': 2, 'c': 3, 'a': 4, 'b': 5}\nprint(dct)\n\n{'a': 4, 'b': 5, 'c': 3}\n\n\n\n# 딕셔너리 생성4 : (key, value) 쌍의 리스트 사용\ndct = dict([('x', 100), ('y', 200)])\nprint(dct)\n\n{'x': 100, 'y': 200}\n\n\n\n# 딕셔너리 생성5 : zip() 함수 사용\nkeys = ['name', 'age', 'city']\nvalues = ['Alice', 28, 'Jeonju']\ndct = dict(zip(keys, values))\nprint(dct)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n\n\n\n# 딕셔너리 생성6 : enumerate() 함수 사용\nfruits = ['apple', 'banana', 'cherry']\ndct = dict(enumerate(fruits))\nprint(dct)\n\n{0: 'apple', 1: 'banana', 2: 'cherry'}\n\n\n\n\n\n3.5.2. 딕셔너리 값 접근\n\n딕셔너리는 키를 사용하여 값에 접근함\n리스트, 튜플처럼 정수 인덱스를 이용한 접근은 불가능함\n\n\n\n# 키를 이용한 값 접근\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(info['name'])\nprint(info['age'])\n\nAlice\n28\n\n\n\n# 딕셔너리는 가변형 객체이므로 키를 이용한 수정이 가능함\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ninfo['city'] = 'Iksan'\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Iksan'}\n\n\n\n# 새로운 키-값 쌍 추가\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ninfo['email'] = 'alice123@gmail.com'\nprint(info)\n\n{'name': 'Alice', 'age': 28, 'city': 'Jeonju', 'email': 'alice123@gmail.com'}\n\n\n\n\n\n3.5.3. 딕셔너리 메소드\n\n3.5.3.1. 딕셔너리 조회\n\n\n\n함수\n설명\n\n\n\n\nkeys()\n딕셔너리의 모든 키를 반환(dict_keys 객체)\n\n\nvalues()\n딕셔너리의 모든 값을 반환(dict_values 객체)\n\n\nitems()\n(키, 값) 쌍을 튜플 형태로 반환(dict_items 객체)\n\n\nget()\n지정한 키의 값을 반환하며, 없으면 None 반환\n\n\nin 연산자\n특정 키가 딕셔너리에 있다면 True, 없다면 False 반환\n\n\n\n\n\n# 모든 키\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.keys()))\n\n['name', 'age', 'city']\n\n\n\n# 모든 값\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.values()))\n\n['Alice', 28, 'Jeonju']\n\n\n\n# (키, 값) 쌍\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(list(info.items()))\n\n[('name', 'Alice'), ('age', 28), ('city', 'Jeonju')]\n\n\n\n# 키를 이용한 값 조회\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint(info.get('name'))\nprint(info.get('email'))\n\nAlice\nNone\n\n\n\n# 특정 키 찾기\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nprint('age' in info)\nprint('email' in info)\n\nTrue\nFalse\n\n\n\n\n\n3.5.3.2. 딕셔너리 추가/삭제\n\n\n\n함수\n설명\n\n\n\n\nupdate()\n다른 딕셔너리나 키워드 인수를 이용하여 원소를 추가 및 수정\n\n\npop()\n특정 키의 값을 삭제하고 그 값을 반환하며, 키가 없으면 오류 발생\n\n\npopitem()\n마지막 (키, 값) 쌍을 삭제하고 반환\n\n\ndel 키워드\n특정 키의 원소를 삭제하며, 키가 없으면 오류 발생\n\n\nclear()\n딕셔너리의 모든 원소를 삭제\n\n\n\n\n\n# 원소 추가 및 수정1\ninfo = {'name': 'Alice', 'age': 28}\ninfo.update({'age': 29, 'city': 'Jeonju'})\nprint(info)\n\n{'name': 'Alice', 'age': 29, 'city': 'Jeonju'}\n\n\n\n# 원소 추가 및 수정2\ninfo = {'name': 'Alice', 'age': 28}\ninfo.update(age=29, city='Jeonju')\nprint(info)\n\n{'name': 'Alice', 'age': 29, 'city': 'Jeonju'}\n\n\n\n# 특정 키의 값 삭제1\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nage = info.pop('age')\nprint(info)\nprint(age)\n\n{'name': 'Alice', 'city': 'Jeonju'}\n28\n\n\n\n# 특정 키의 값 삭제2\n#info = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n#age = info.pop('email')\n#print(info)\n#print(email)\n\n\n# 마지막 (키, 값) 쌍 삭제\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\nlast_item = info.popitem()\nprint(info)\nprint(last_item)\n\n{'name': 'Alice', 'age': 28}\n('city', 'Jeonju')\n\n\n\n# 특정 키의 원소 삭제1\ninfo = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\ndel info['age']\nprint(info)\n\n{'name': 'Alice', 'city': 'Jeonju'}\n\n\n\n# 특정 키의 원소 삭제2\n#info = {'name': 'Alice', 'age': 28, 'city': 'Jeonju'}\n#del info['email']\n#print(info)"
  },
  {
    "objectID": "1_environment.html",
    "href": "1_environment.html",
    "title": "\n\nPython 개발 환경\n",
    "section": "",
    "text": "Python 개발 환경"
  },
  {
    "objectID": "1_environment.html#python",
    "href": "1_environment.html#python",
    "title": "\n\nPython 개발 환경\n",
    "section": "1.1. Python",
    "text": "1.1. Python\n\n컴퓨터 프로그램과 프로그래밍 언어\n\n컴퓨터 프로그램 (computer program) : 컴퓨터로 문제를 해결하기 위해 작성하는 명령어의 모음\n프로그래밍 언어(programming language)\n\n컴퓨터에 어떤 동작을 수행하도록 지시하는 언어\n프로그래밍 언어를 사용하여 프로그램을 논리적으로 작성하는 작업을 코딩(coding)이라 함\n\n\n\n\n\nPython\n\n1991년 귀도 반 로섬(Guido van Rossum)이 개발한 프로그래밍 언어\n빅데이터 분석과 인공지능 분야에서 가장 널리 사용되고 있음\n문법이 쉽고 간결하여 프로그래밍을 처음 접하는 사람이 배우기 적합함\n\n\n\n\nPython 특징\n\n플랫폼 독립적인 언어 : 컴퓨터 운영체제나 하드웨어의 종류에 관계없이 사용할 수 있음\n인터프리터 언어 : 소스코드 자체가 바로 실행되어 간편하게 사용할 수 있음(속도는 느림)\n동적 타이핑 언어\n\n프로그램의 실행 시점에서 각 프로그램 변수의 타입(type)을 결정하는 언어\n인터프리터 언어이므로 프로그램의 실행 시점에 변수들의 메모리 공간을 자유롭게 할당받을 수 있음\n\n객체 지향 언어\n\n프로그램이 해결해야 할 문제의 구성요소를 요소별로 정의한 다음, 각 요소의 기능(method)과 정보(attribute)를 프로그래밍한 다음 요소들을 결합하는 방식으로 프로그램을 작성함\n이때 각 요소를 객체(object)라고 하며, 한 번 만들어진 객체는 재사용(reusability)할 수 있음"
  },
  {
    "objectID": "1_environment.html#python-설치",
    "href": "1_environment.html#python-설치",
    "title": "\n\nPython 개발 환경\n",
    "section": "1.2. Python 설치",
    "text": "1.2. Python 설치\n\n1.2.1. Anaconda\n\n대규모 데이터 처리, 예측 분석, 과학적 컴퓨팅을 위한 Python 언어의 오픈소스 배포판\nJupyter Notebook, Spyder 등 주요 개발 도구가 함께 설치되어 별도 설정 없이 바로 사용 가능\n데이터 분석, 머신러닝 분야에서 널리 활용됨\n\n\n\n\n1.2.2. Python 실행 도구\n\nPython 코드를 작성하고 실행할 수 있는 다양한 텍스트 편집기 및 IDE(통합개발환경)이 존재함\n설치 유무, 기능, 편의성 등에 따라 적절한 도구를 선택하여 사용할 수 있음\n\n\n\n\n\n\n\n\n도구\n설명\n\n\n\n\n메모장\n- 추가 설치가 필요없으나, 기능이 제한적이고 불편함\n\n\nIDLE\n- Python 설치 시 기본 제공되는 개발 환경 - 가볍고 간단한 코드 테스트에 적합\n\n\nJupyter Notebook\n- 웹 기반 인터페이스로, 문서화와 시각화에 유리함 - Anaconda에 기본 포함됨\n\n\nSpyder\n- 과학 계산에 특화된 IDE - Anaconda에 기본 포함되며, 디버거 기능 제공\n\n\nPyCharm\n- 전문적인 기능을 갖춘 IDE로, 별도 설치 필요 - 대규모 프로젝트 개발에 적합하며 사용률이 높음\n\n\nVisual Studio Code\n- 다양한 언어를 지원하는 확장 가능한 편집기 - Python 개발에도 많이 사용되며, 별도 설치 필요\n\n\n\n\n\n\n\n1.2.3. Google Colab\n\nGoogle Colab\n\n구글에서 제공하는 클라우드 기반의 Jupyter Notebook 개발 환경으로, 웹 브라우저에서 Python 코드 작성 및 실행이 가능함\n별도의 설치 없이 바로 사용할 수 있으며, 구글 드라이브와 연동하여 작성한 파일을 클라우드에 저장하고 쉽게 관리할 수 있음\n다양한 라이브러리(NumPy, Pandas, Matplotlib 등)가 기본적으로 설치되어 있음\nGPU, TPU 지원을 통해 대규모 데이터 처리와 딥러닝 모델 학습에 유리함\n협업 기능을 제공하여, 여러 사람이 동시에 실시간으로 작업하고 프로그램을 공유할 수 있음"
  },
  {
    "objectID": "10_seaborn.html",
    "href": "10_seaborn.html",
    "title": "\n\nSeaborn\n",
    "section": "",
    "text": "Seaborn"
  },
  {
    "objectID": "10_seaborn.html#seaborn",
    "href": "10_seaborn.html#seaborn",
    "title": "\n\nSeaborn\n",
    "section": "10.1. Seaborn",
    "text": "10.1. Seaborn\n\nSeaborn\n\nMatplotlib 라이브러리를 기반으로 개발된 고급 통계 데이터 시각화 라이브러리\n다양한 테마와 통계 그래프를 지원하며, 시각적으로 세련된 그래프를 쉽게 생성할 수 있음\nMatplotlib 라이브러리에 의존하므로, 사용 시 함께 불러와야 함\n\n\n\n\n[실습 데이터]\n\n공공데이터포털에서 제공하는 2020년 국민건강보험공단 건강검진 정보\nhealth_2020.csv\n\n\n\n\n\n\n변수\n설명\n\n\n\n\ngender\n성별 코드 (남자: 1, 여자: 2)\n\n\nheight\n키 (5cm 단위)\n\n\nweight\n몸무기 (5cm 단위)\n\n\nwaist\n허리둘레\n\n\nsystolic\n수축기 혈압\n\n\ndiastolic\n이완기 혈압\n\n\ncholesterol\n총콜레스테롤\n\n\nHDL\nHDL 콜레스테롤\n\n\nLDL\nLDL 콜레스테롤\n\n\nsmoking\n흡연 상태 (비흡연: 1, 과거 흡연: 2, 현재 흡연: 3)\n\n\ndrinking\n음주 여부 (비음주: 0, 음주: 1)"
  },
  {
    "objectID": "10_seaborn.html#막대-그래프",
    "href": "10_seaborn.html#막대-그래프",
    "title": "\n\nSeaborn\n",
    "section": "10.2. 막대 그래프",
    "text": "10.2. 막대 그래프\n\n\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\n## 실습 데이터 : health_2020 데이터셋\ndata = pd.read_csv('./data/health_2020.csv')\nprint(data.head())\n\n   no  city_code  gender  age_code  height  weight  waist  systolic  \\\n0   1         36       1         9     165      60   72.1       127   \n1   5         41       2        12     155      50   75.2       144   \n2   6         27       1         9     185      85   94.0       114   \n3   7         44       1         9     165      80   93.0       112   \n4   9         41       2        17     150      50   82.0       136   \n\n   diastolic  blood_sugar  cholesterol  triglycerides   HDL  LDL  hemoglobin  \\\n0         79           90          188             58  58.0  118        15.0   \n1         89          110          220            171  53.0  133        12.4   \n2         72           86          234            183  50.0  147        16.4   \n3         73          250          119            265  26.0   40        15.7   \n4         65          104          177             61  63.0  101        13.3   \n\n   serum  smoking  drinking  \n0    1.1        1         0  \n1    0.7        1         0  \n2    1.1        3         1  \n3    0.7        3         1  \n4    0.7        1         0  \n\n\n\n## 라벨 매핑(label mapping)\n# replace() 함수는 명시되지 않은 값을 그대로 유지하지만,\n# map() 함수는 명시되지 않은 값을 NaN으로 처리함\ndata6 = data.copy()\ndata6 = data6.loc[:, ['gender', 'height', 'weight', 'waist', 'drinking', 'smoking']]\ndata6['gender'] = data['gender'].replace({1: 'M', 2: 'F'})\ndata6['drinking'] = data['drinking'].replace({0: 'Non-drinking', 1: 'Drinking'})\ndata6['smoking'] = data['smoking'].replace({1: 'Non-smoking', 2: 'Quit-smoking', 3: 'Smoking'})\nprint(data6.head())\n\n  gender  height  weight  waist      drinking      smoking\n0      M     165      60   72.1  Non-drinking  Non-smoking\n1      F     155      50   75.2  Non-drinking  Non-smoking\n2      M     185      85   94.0      Drinking      Smoking\n3      M     165      80   93.0      Drinking      Smoking\n4      F     150      50   82.0  Non-drinking  Non-smoking\n\n\n\n# 성별 음주 여부별 빈도\ndrinking = data6.groupby(['gender', 'drinking'])['drinking'].count()\ndrinking = drinking.to_frame(name='count')\ndrinking = drinking.reset_index()\nprint(drinking)\n\n  gender      drinking  count\n0      F      Drinking    611\n1      F  Non-drinking    888\n2      M      Drinking   1086\n3      M  Non-drinking    415\n\n\n\n# 성별 흡연 상태별 빈도\nsmoking = data6.groupby(['gender', 'smoking'])['smoking'].count()\nsmoking = smoking.to_frame(name='count')\nsmoking = smoking.reset_index()\nprint(smoking)\n\n  gender       smoking  count\n0      F   Non-smoking   1422\n1      F  Quit-smoking     45\n2      F       Smoking     32\n3      M   Non-smoking    502\n4      M  Quit-smoking    519\n5      M       Smoking    480\n\n\n\n# 막대 그래프1 : 성별에 따른 음주 여부, 흡연 상태 분포\nfig = plt.figure(figsize=(6, 4))\narea1 = fig.add_subplot(1, 2, 1)\narea2 = fig.add_subplot(1, 2, 2)\n\nax1 = sns.barplot(x='gender', y='count', hue='drinking', data=drinking, ax=area1)\nax2 = sns.barplot(x='gender', y='count', hue='smoking', data=smoking, ax=area2)\n\nfig.suptitle('2020 Health Check Drinking & Smoking Type by Gender', fontweight='bold')\narea1.set_title('Drinking Type')\narea2.set_title('Smoking Type')\nplt.tight_layout(rect=[0, 0, 1, 0.99])\nplt.show()\n\n\n\n\n\n\n\n\n\n# 성별 흡연 상태별 평균 몸무게\nmean_weight = data6.groupby(['gender', 'smoking'])['weight'].mean()\nmean_weight = mean_weight.to_frame(name='mean')\nmean_weight = mean_weight.reset_index()\nprint(mean_weight)\n\n  gender       smoking       mean\n0      F   Non-smoking  55.706751\n1      F  Quit-smoking  55.555556\n2      F       Smoking  59.843750\n3      M   Non-smoking  68.914343\n4      M  Quit-smoking  70.337187\n5      M       Smoking  69.052083\n\n\n\n# 막대 그래프2 : 성별과 흡연 상태에 따른 평균 몸무게\nplt.figure(figsize=(5, 3))\nsns.barplot(x='gender', y='mean', hue='smoking', data=mean_weight)\nplt.show()"
  },
  {
    "objectID": "10_seaborn.html#히스토그램",
    "href": "10_seaborn.html#히스토그램",
    "title": "\n\nSeaborn\n",
    "section": "10.3. 히스토그램",
    "text": "10.3. 히스토그램\n\n\n# 성별에 따라 데이터 분리\nmaledata = data6.copy()\nmaledata = maledata.loc[maledata['gender']=='M',:]\n\nfemaledata = data6.copy()\nfemaledata = femaledata.loc[femaledata['gender']=='F',:]\n\n\n# 히스토그램1 : 성별에 따른 몸무게 분포\nplt.figure(figsize=(5, 3))\nplt.title('Distribution of Weight')\nsns.histplot(maledata['weight'], bins=8, alpha=0.5, label='Male')\nsns.histplot(femaledata['weight'], bins=8, alpha=0.5, label='Female', color='r')\nplt.xlim(20, 130)\nplt.xlabel('weight')\nplt.ylabel('count')\nplt.legend()\nplt.show()\n\n\n\n\n\n\n\n\n\n# 히스토그램 & 커널 밀도 추정(KDE) : 성별에 따른 허리둘레 분포\nplt.figure(figsize=(5, 3))\nplt.title('Distribution of Waist with KDE')\nsns.histplot(maledata['waist'], bins=7, alpha=0.5, label='Male', kde=True)\nsns.histplot(femaledata['waist'], bins=7, alpha=0.5, label='Female', color='r', kde=True)\nplt.xlim(40,130)\nplt.xlabel('waist')\nplt.ylabel('count')\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "10_seaborn.html#상자그림",
    "href": "10_seaborn.html#상자그림",
    "title": "\n\nSeaborn\n",
    "section": "10.4. 상자그림",
    "text": "10.4. 상자그림\n\n# 상자그림1 : 성별 및 음주 여부에 따른 몸무게 분포\nplt.figure(figsize=(6, 4))\nplt.title('Weight By Gender and Drinking')\nsns.boxplot(x='gender', y='weight', hue='drinking', width=0.7, gap = 0.1, data=data6)\nplt.show()\n\n\n\n\n\n\n\n\n\n# 상자그림2 : 성별 및 흡연 상태에 따른 몸무게 분포\nplt.figure(figsize=(6, 6))\nplt.title('Weight By Gender and Smoking')\nsns.boxplot(x='weight', y='gender', hue='smoking', width=0.7, gap=0.1, data=data6, orient='h')\nplt.show()"
  },
  {
    "objectID": "10_seaborn.html#카운트-플롯count-plot",
    "href": "10_seaborn.html#카운트-플롯count-plot",
    "title": "\n\nSeaborn\n",
    "section": "10.5. 카운트 플롯(count plot)",
    "text": "10.5. 카운트 플롯(count plot)\n\n범주형 변수의 각 항목별 빈도를 막대 그래프로 표현함\n데이터의 범주별 분포를 직관적으로 파악할 수 있음\n\n\n\n# 카운트 플롯1 : 음주 여부에 따른 성별 분포\nplt.figure(figsize=(5, 3))\nplt.title('Gender and Drinking')\nsns.countplot(x='drinking', hue='gender', data=data6)\nplt.xlabel('')\nplt.show()\n\n\n\n\n\n\n\n\n\n# 카운트 플롯2 : 흡연 상태에 따른 성별 분포\nplt.figure(figsize=(5, 3))\nplt.title('Gender and Smoking')\nsns.countplot(y='smoking', hue='gender',\n              data=data6, order=['Smoking', 'Quit-smoking', 'Non-smoking'])\nplt.ylabel('')\nplt.show()"
  },
  {
    "objectID": "10_seaborn.html#히트맵heatmap",
    "href": "10_seaborn.html#히트맵heatmap",
    "title": "\n\nSeaborn\n",
    "section": "10.6. 히트맵(heatmap)",
    "text": "10.6. 히트맵(heatmap)\n\n행과 열로 이루어진 2차원 행렬 데이터를 색상으로 시각화함\n두 범주형 변수 간의 관계나 상관관계를 나타낼 때 사용\n색상의 강도를 통해 값의 크기를 비교할 수 있음\n(예) 상관행렬, 교차표 등\n\n\n\n# 8개 건강 지표 선택\ndata8 = data.copy()\ndata8 = data8.loc[:, ['height', 'weight', 'waist',\n                      'systolic', 'diastolic', 'cholesterol', 'HDL', 'LDL']]\n\n\n# 히트맵 : 8개의 건강 지표 간 상관관계\ncorrelation_data8 = data8.corr()\nupp_mat = np.triu(correlation_data8)\n\nplt.figure(figsize=(8, 6))\nplt.title('Correlation Heatmap')\nsns.heatmap(correlation_data8, annot=True, mask=upp_mat, cmap='seismic', vmin=-1, vmax=1)\nplt.xticks(rotation=45)\nplt.show()"
  },
  {
    "objectID": "2_basic.html",
    "href": "2_basic.html",
    "title": "\n\n기초 문법\n",
    "section": "",
    "text": "기초 문법"
  },
  {
    "objectID": "2_basic.html#변수",
    "href": "2_basic.html#변수",
    "title": "\n\n기초 문법\n",
    "section": "2.1. 변수",
    "text": "2.1. 변수\n\n변수\n\n프로그램이 실행되는 동안 값을 저장하는 공간\n하나의 프로그램에서 여러 개의 변수를 만들어 사용할 수 있으며, 각 변수를 구분하기 위해 변수마다 이름을 붙여 관리함\n변수에는 언제든지 새로운 값을 저장할 수 있음\n\n\n\n\n대입 연산자 =\n\n변수에 값을 저장할 때 사용하는 연산자로, 할당 연산자라고도 함\n= 기호 오른쪽의 값을 = 기호 왼쪽의 변수에 저장한다는 의미\n\n\n\n\n# 변수에 값을 저장하고 출력\nage = 20\nprint(age)\n\n20\n\n\n\n# 변수에 저장된 값 변경\nage = 21\nprint(age)\n\n21\n\n\n\n# 여러 변수에 값 대입\na = b = c = 7\nprint(a)\nprint(b)\nprint(c)\n\n7\n7\n7\n\n\n\n# 코드 한 줄에서 여러 개의 변수에 각각 다른 값을 한번에 대입할 수 있음\na, b, c = 7, 11, 19\nprint(a)\nprint(b)\nprint(c)\n\n7\n11\n19\n\n\n\n# 일반적인 프로그래밍 언어에서 두 변수의 값 교환\na = 7\nb = 11\ntmp = a\na = b\nb = tmp\nprint(a, b)\n\n11 7\n\n\n\n# Python에서는 임시변수 없이 두 변수의 값을 쉽게 교환할 수 있음 (패킹과 언패킹)\na = 7\nb = 11\na, b = b, a\nprint(a, b)\n\n11 7\n\n\n\n\n변수명 작성 규칙\n\n변수가 어떤 용도로 쓰이는지 잘 설명하는 이름으로 만드는 것이 좋음\n첫 번째 글자는 문자 또는 _이어야 하고, 나머지 글자는 문자, 숫자, _이어야 함\n영문 대문자와 소문자를 구분함\n키워드(예약어; keyword)는 사용할 수 없음\n\n키워드 : 프로그래밍 언어에서 사용하기 위해 쓰임새를 미리 정해 놓은 단어\n\n\n\n\n\nimport keyword\nprint(keyword.kwlist)\n\n['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']"
  },
  {
    "objectID": "2_basic.html#자료형",
    "href": "2_basic.html#자료형",
    "title": "\n\n기초 문법\n",
    "section": "2.2. 자료형",
    "text": "2.2. 자료형\n\n기본 자료형\n\n단순한 값을 저장하는 자료형\n(예) 정수(1,2,3,…), 부동소수점수(1.23, 3.14, …), 문자열(“Hello”), bool(True, False)\n\n구조적 자료형\n\n여러 개의 값을 담을 수 있는 자료형\n(예) 리스트(list), 튜플(tuple), 세트(set), 딕셔너리(dictionary)\n\ntype() 함수를 이용하여 자료형을 확인할 수 있음\n\n\n\n# 정수형\na = 20                      # 10진수\nb = 0o34                    # 8진수\nc = 0xA1                    # 16진수\nd = 0b1110                  # 2진수\nprint(a, b, c, d)\nprint(type(a))\n\n20 28 161 14\n&lt;class 'int'&gt;\n\n\n\n# 부동소수점수형\na = 3.14\nb = 1.23e5                  # 지수 표현 방식\nprint(a, b)\nprint(type(a))\n\n3.14 123000.0\n&lt;class 'float'&gt;\n\n\n\n# 문자열형\na = 'Hello'\nb = \"Python\"\nprint(a, b)\nprint(type(a))\n\nHello Python\n&lt;class 'str'&gt;\n\n\n\n# bool형\na = 10&gt;20\nprint(a)\nprint(type(a))\n\nFalse\n&lt;class 'bool'&gt;"
  },
  {
    "objectID": "2_basic.html#표준-입출력",
    "href": "2_basic.html#표준-입출력",
    "title": "\n\n기초 문법\n",
    "section": "2.3. 표준 입출력",
    "text": "2.3. 표준 입출력\n\n입력\n\n사용자로부터 데이터를 입력받기 위해 input() 함수를 이용함\ninput() 함수는 안내문을 출력한 후 사용자의 입력을 기다리며, 입력한 데이터를 문자열 형식으로 반환함\n입력한 값을 숫자로 사용하려면 int(), float() 함수를 이용하여 자료형 변환을 해야 함\n변수 = input(안내문)\n\n\n\n\n출력\n\n데이터를 출력하기 위해 print() 함수를 이용함\n여러 개의 값을 출력하려면 ,로 구분한 값을 나열하면 됨\n\n\n\n\n# 문자열 입력\n#name = input(\"이름: \")\n#age = input(\"나이: \")\n#print(name, \"나이:\", age)\n\n\n# 정수 형식의 문자열 입력\n# input 함수를 통해서 입력받은 데이터는 문자열형임\n# 따라서 int() 함수를 이용하여 정수 형식의 문자열을 정수로 변환해야 함\n#a = int(input(\"정수: \"))\n#b = int(input(\"정수: \"))\n#print(a-b)\n\n\n# 부동소수점수 형식의 문자열 입력\n# float() 함수를 이용하여 부동소수점수 형식의 문자열을 부동소수점수로 변환함\n#minute = float(input(\"분 단위 시간: \"))\n#second = minute * 60\n#print(second, \"초\")\n\n\n# 문자열 출력\nprint(\"안녕하세요.\")\nage = 25\nprint(\"나이는\", age, \"입니다.\")\n\n안녕하세요.\n나이는 25 입니다.\n\n\n\n# print() 함수가 여러 개일 때는 다음 줄로 넘어가서 값을 출력함\na = 25\nb = 42\nprint(a)\nprint(b)\n\n25\n42\n\n\n\n# print() 함수가 여러 개일 때 다음 줄로 넘어가는 대신 공백이 출력되기를 원하면 end 매개변수를 공백으로 설정함\na = 25\nb = 42\nprint(a, end=' ')\nprint(b)\n\n25 42\n\n\n\n\nf-string 포맷팅\n\n문자열 맨 앞에 f 또는 F를 붙이고, {} 안에 변수명을 직접 작성하여 출력하는 방식\n가독성이 좋고 사용 방법이 간단하여 자주 사용됨\n\n\n\n\n# f-string 사용\nname = \"홍길동\"\nage = 20\nprint(f\"이름은 {name}이고, 나이는 {age}입니다.\")\n\n이름은 홍길동이고, 나이는 20입니다.\n\n\n\n# f-string 출력 형식 지정\n# 변수명 옆에 :을 작성한 다음 형식을 지정함\nname = \"홍길동\"\nage = 20\nprint(f\"{name:5}, {age:3}\")\n\na = 4\nb = 3.14159265\nprint(f\"20{a:02d}\")                        # a 값을 두자리로 출력하되 앞의 빈곳은 0으로 채움\nprint(f\"{b:.3f}\")                          # b 값을 소수점 이하 세자리로 반올림하여 출력\n\n홍길동  ,  20\n2004\n3.142"
  },
  {
    "objectID": "2_basic.html#연산자",
    "href": "2_basic.html#연산자",
    "title": "\n\n기초 문법\n",
    "section": "2.4. 연산자",
    "text": "2.4. 연산자\n\n연산(operation) : 덧셈, 뺄셈 등과 같이 일정한 규칙에 따라 계산하는 것\n\n\n\n2.4.1. 산술 연산자\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n+\n더하기\nprint(6+4)\n10\n\n\n-\n빼기\nprint(6-4)\n2\n\n\n*\n곱하기\nprint(6*4)\n24\n\n\n/\n나누기\nprint(6/4)\n1.5\n\n\n//\n나눈 정수 몫\nprint(6//4)\n1\n\n\n%\n나눈 나머지\nprint(6%4)\n2\n\n\n**\n거듭제곱\nprint(6**4)\n1296\n\n\n\n\n\n\n2.4.2. 비교 연산자\n\n크기를 비교할 때 사용하는 연산자\n연산 결과는 참(True) 또는 거짓(False)으로 나타남\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n==\n같다\nprint(10==20)\nFalse\n\n\n!=\n같지 않다\nprint(10!=20)\nTrue\n\n\n&gt;\n크다\nprint(10&gt;20)\nFalse\n\n\n&lt;\n작다\nprint(10&lt;20)\nTrue\n\n\n&gt;=\n크거나 같다\nprint(10&gt;=20)\nFalse\n\n\n&lt;=\n작거나 같다\nprint(10&lt;=20)\nTrue\n\n\n\n\n\n\n2.4.3. 논리 연산자\n\n참과 거짓의 논리 동작을 다루는 연산\n여러 조건을 조합할 때 주로 사용함\n\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\nand\n왼쪽 식과 오른쪽 식 모두 참인 경우에만 True\na=25 print(a&gt;8 and a&lt;60)\nTrue\n\n\nor\n왼쪽 식과 오른쪽 식 중 하나라도 참인 경우에만 True\na=70 print(a&lt;8 or a&gt;=60)\nTrue\n\n\nnot\n오른쪽 식이 참이면 False, 거짓이면 True\na=20 print(not a==20)\nFalse\n\n\n\n\n\n\n2.4.4. 복합 대입 연산자\n\n연산한 값을 다시 대입하는 연산자\n\n\n\n\n\n\n\n\n\n\n연산자\n설명\n예시\n결과\n\n\n\n\n+=\n왼쪽 값에 오른쪽 값을 더한 결과를 다시 왼쪽에 대입\na, b = 2, 3 a += b  print(a)\n5\n\n\n-=\n왼쪽 값에 오른쪽 값을 뺀 결과를 다시 왼쪽에 대입\na, b = 2, 3 a -= b  print(a)\n-1\n\n\n*=\n왼쪽 값에 오른쪽 값을 곱한 결과를 다시 왼쪽에 대입\na, b = 2, 3 a *= b  print(a)\n6\n\n\n/=\n왼쪽 값에 오른쪽 값을 나눈 결과를 다시 왼쪽에 대입\na, b = 3, 2 a /= b  print(a)\n1.5\n\n\n//=\n왼쪽 값에 오른쪽 값을 나눈 몫을 다시 왼쪽에 대입\na, b = 7, 3 a //= b  print(a)\n2\n\n\n%=\n왼쪽 값에 오른쪽 값을 나눈 나머지를 다시 왼쪽에 대입\na, b = 7, 3 a %= b  print(a)\n1\n\n\n\n\n\n\n2.4.5. 연산자 우선순위\n\n프로그래밍 언어는 연산자에 우선순위를 부여하여 우선순위가 높은 연산자를 먼저 계산함\n우선순위에 관계없이 연산의 순서를 정하려면 괄호 ()를 사용함\n\n\n\n\n우선순위\n연산자\n설명\n\n\n\n\n1\n**\n거듭제곱 연산자\n\n\n2\n+, -\n양수, 음수를 나타내는 단항 연산자\n\n\n3\n*, /, //, %\n곱셈, 나눗셈, 나눈 몫, 나머지\n\n\n4\n+, -\n덧셈, 뺄셈\n\n\n5\n&lt;, &lt;=, &gt;, &gt;=\n비교 연산자\n\n\n6\n==, !=\n동등 연산자\n\n\n7\n=, +=, -=, /=, //=, %=, **=\n대입 연산자\n\n\n8\nnot\n논리 연산자\n\n\n9\nand\n논리 연산자\n\n\n10\nor\n논리 연산자\n\n\n\n\n\n# 정수 3개의 평균 계산(틀림)\navg = 70 + 80 + 90 / 3\nprint(avg)\n\n180.0\n\n\n\n# 정수 3개의 평균 계산\navg = (70 + 80 + 90) / 3\nprint(avg)\n\n80.0\n\n\n\n# 길이 단위 변환\n#_cm = int(input(\"센티미터 단위 길이: \"))\n#m = _cm // 100\n#cm = _cm % 100\n#print(f'{m}미터 {cm}센티미터')"
  },
  {
    "objectID": "2_basic.html#조건문",
    "href": "2_basic.html#조건문",
    "title": "\n\n기초 문법\n",
    "section": "2.5. 조건문",
    "text": "2.5. 조건문\n\n2.5.1. 프로그램 구조\n\n프로그램 구조는 크게 순차 구조, 선택 구조, 반복 구조로 구분됨\n\n순차 구조 : 위에서부터 아래로 순차적으로 실행되는 구조\n선택 구조 : 조건에 따라 문장을 선택적으로 실행하는 구조로, 조건이 참(True)인지 거짓(False)인지에 따라 실행되는 문장이 달라짐\n반복 구조 : 임의의 문장을 반복해서 실행하는 구조\n\n\n\n\n\n\n\n\n2.5.2. if 문\n\nif 조건식:  　　문장\n\n\n\n조건식이 참이면 문장을 실행하고 거짓이면 문장을 실행하지 않음\n조건식 오른쪽에 :이 위치하고, 참인 경우 실행될 문장은 반드시 들여쓰기(indentation)해야 함\n\n\n\n\n\n# 무작위로 1~100 사이의 두 정수를 생성한 후, 큰 수부터 작은 수 순으로 출력\nimport random\na = random.randint(1, 100)\nb = random.randint(1, 100)\n\nif a&lt;b:\n    a, b = b, a\n\nprint(a, b)\n\n91 63\n\n\n\n\n\n2.5.3. if~else 문\n\nif 조건식:  　　문장1  else:  　　문장2\n\n\n\n조건식이 참이면 문장1을 실행하고, 거짓이면 문장2를 실행함\n조건식 오른쪽에 :이 위치하고, else 오른쪽에는 조건식 없이 :이 위치함\n문장1과 문장2는 반드시 들여쓰기해야 함\n\n\n\n\n\n# 무작위로 1~100 사이의 정수를 생성한 후, 짝수인지 홀수인지 판단\nimport random\na = random.randint(1, 100)\n\nif a % 2 == 0:\n    print(f'{a}는 짝수입니다')\nelse:\n    print(f'{a}는 홀수입니다')\n\n62는 짝수입니다\n\n\n\n\n\n2.5.4. if~elif~else문\n\nif 조건식1:  　　문장1  elif 조건식2:  　　문장2  else:  　　문장3\n\n\n\n조건식1이 거짓인 경우에 또 다른 선택구조를 연결하는 구조\n조건식1이 참이면 문장1을 실행하고, 조건식1이 거짓이면서 조건식2가 참이면 문장2를 실행하고, 두 조건식 모두 거짓이면 문장3을 실행함\n조건식1, 조건식2 오른쪽에 :이 위치하고, 문장1, 문장2, 문장3은 반드시 들여쓰기해야 함\n\n\n\n\n\n# 놀이공원 기본 입장료는 5,000원임\n# 8세 미만은 기본 입장료 30% 할인, 65세 이상은 기본 입장료 20% 할인 적용함\n# 연령이 주어졌을 때, 놀이공원 입장료 산출\nfee = 5000\nage = 7\n\nif age &lt; 8:\n    print('입장료:', fee*0.7)\nelif age &lt; 65:\n    print('입장료:', fee)\nelse:\n    print('입장료:', fee*0.8)\n\n입장료: 3500.0"
  },
  {
    "objectID": "2_basic.html#반복문",
    "href": "2_basic.html#반복문",
    "title": "\n\n기초 문법\n",
    "section": "2.6. 반복문",
    "text": "2.6. 반복문\n\n2.6.1. for 문\n\nfor 반복변수 in 반복범위:  　　문장\n\n\n\n반복범위를 지정하여(정해진 횟수만큼) 반복해서 문장을 실행함\n반복범위 오른쪽에는 :이 위치하고, 반복해서 실행할 문장은 반드시 들여쓰기해야 함\n반복범위에는 범위, 문자열, 리스트, 딕셔너리 등이 사용될 수 있음\n\n그 중 범위가 가장 많이 사용되며, range() 함수로 만들 수 있음\n\n\n\n\n\n\n\n\n\n\n\n형식\n설명\n예시\n결과\n\n\n\n\nrange(종료값)\n0으로 시작해서 1씩 증가하며 종료값 전까지의 정수를 생성\nrange(5)\n0,1,2,3,4\n\n\nrange(시작값, 종료값)\n시작값으로 시작해서 1씩 증가하며 종료값 전까지의 정수를 생성\nrang(2,7)\n2,3,4,5,6\n\n\nrange(시작값, 종료값, 증가값)\n시작값으로 시작해서 증가값만큼 증가시키면서 종료값 전까지의 정수를 생성\nrange(2,11,3)\n2,5,8\n\n\n\n\n\n# 문자열을 3번 반복해서 출력\nfor i in range(3):\n    print(\"Hello!\")\n\nHello!\nHello!\nHello!\n\n\n\n# 반복범위의 값을 출력1\nfor i in range(5):\n    print(i)\n\n0\n1\n2\n3\n4\n\n\n\n# 반복범위의 값을 출력2\nfor i in \"World\":\n    print(i)\n\nW\no\nr\nl\nd\n\n\n\n# 1~100 정수의 합 계산\nsum = 0\n\nfor i in range(1,101):\n    sum += i\n\nprint(sum)\n\n5050\n\n\n\n# 30의 약수 출력\nnum = 30\n\nfor i in range(1, num+1):\n    if num%i == 0:\n        print(i, end=' ')\n\n1 2 3 5 6 10 15 30 \n\n\n\n\n\n2.6.2. while 문\n\nwhile 조건식:  　　문장\n\n\n\n조건이 참인 동안 문장을 반복해서 실행하고, 조건이 거짓이면 반복문을 종료함\n\n\n\n# 1~100 정수의 합 계산\nsum = 0\nnum = 1\n\nwhile num&lt;=100:\n    sum += num\n    num += 1\n\nprint(sum)\n\n5050\n\n\n\n# 구구단 9단 출력\nnum = 1\n\nwhile num&lt;=9:\n    print(f'9x{num}={9*num}')\n    num += 1\n\n9x1=9\n9x2=18\n9x3=27\n9x4=36\n9x5=45\n9x6=54\n9x7=63\n9x8=72\n9x9=81"
  },
  {
    "objectID": "2_basic.html#함수",
    "href": "2_basic.html#함수",
    "title": "\n\n기초 문법\n",
    "section": "2.7. 함수",
    "text": "2.7. 함수\n\n2.7.1. 함수의 개념\n\n함수(function)\n\n특정한 기능을 수행하도록 미리 만들어 놓고, 필요할 때마다 호출하여 사용하는 일련의 코드\nPython에서 기본적으로 제공하는 내장 함수와 사용자가 직접 만들어서 사용할 수 있는 사용자 정의 함수가 있음\n\n\n\n\n함수의 장점\n\n필요할 때마다 호출 가능 : 반복적으로 수행해야 하는 업무를 한 번만 작성해 놓고 필요할 때마다 호출하여 사용할 수 있음\n논리적인 단위로 분할 가능 : (예) 도형 계산 프로그램 - 덧셈 코드, 곱셈 코드, 나눗셈 코드 등으로 나눔\n코드의 캡슐화 가능 : 함수의 인터페이스만 잘 정의하면 다른 사람이 자신의 코드를 쉽게 가져다 사용할 수 있음\n\n\n\n\n# 절대값 반환 함수\nabs(-10)\n\n10\n\n\n\n\n\n2.7.2. 함수 정의\n\ndef 함수명(매개변수1, 매개변수2, …):  　　문장  　　return 반환값\n\n\n\n함수명 작성 규칙\n\n변수명 작성 규칙과 동일함\n일반적으로 소문자로 입력\n작업을 나타내기 위해 동사와 명사를 함께 사용하는 경우가 많음 - (예) find_number\n외부에 공개하는 함수일 경우 줄임말을 사용하지 않고 짧고 명료한 이름으로 정함\n\n\n\n\n매개변수(parameter)\n\n함수에서 입력값으로 사용하는 변수로, 1개 이상의 값을 적을 수 있음\n\n\n\n\n함수 형태\n\n\n\n\n\n\n\n\n\n구분\n매개변수 ×\n매개변수 ○\n\n\n\n\n반환값 ×\n함수 내부 명령문만 수행\n매개변수를 사용하여 명령문만 수행\n\n\n반환값 ○\n매개변수 없이 명령문을 수행한 후 결과값 반환\n매개변수를 사용하여 명령문을 수행한 후 결과값 반환\n\n\n\n\n\n# 매개변수 ×, 반환값 ×\ndef func():\n    print('함수입니다.')\n\nprint('함수 호출 전입니다')\nfunc()\nprint('함수 호출 후입니다')\n\n함수 호출 전입니다\n함수입니다.\n함수 호출 후입니다\n\n\n\n# 매개변수 ○, 반환값 ×\ndef add1(x, y):\n    print(x+y)\n\nres1 = add1(10,20)\nprint(res1)\n\n30\nNone\n\n\n\n# 매개변수 ○, 반환값 ○\ndef add2(x, y):\n    return x+y\n\nres2 = add2(10,20)\nprint(res2)\n\n30\n\n\n\n## 섭씨온도를 화씨온도로 변환하는 함수\n# (섭씨온도) = (화씨온도 - 32) × 5/9\ndef f_to_c(fahrenheit):\n    return (fahrenheit-32) * 5/9\n\nf_to_c(100)\n\n37.77777777777778"
  },
  {
    "objectID": "4_string.html",
    "href": "4_string.html",
    "title": "\n\n문자열 처리\n",
    "section": "",
    "text": "문자열 처리"
  },
  {
    "objectID": "4_string.html#문자열-생성",
    "href": "4_string.html#문자열-생성",
    "title": "\n\n문자열 처리\n",
    "section": "4.1. 문자열 생성",
    "text": "4.1. 문자열 생성\n\n문자열(string)\n\n문자(character)들이 나열된 시퀀스 자료형(sequence data type)\n한 번 생성된 이후에는 수정할 수 없는 불변형(immutable) 객체\n큰 따옴표 또는 작은 따옴표로 감싸서 문자열을 생성함\n\n\n\n\n이스케이프 문자(escape character)\n\n\\ 기호와 함께 조합해서 사용하는 특수한 문자\n\\\" : 큰 따옴표\n\\' : 작은 따옴표\n\\n : 줄 바꿈(new line)\n\\t : 탭(tab)\n\n\n\n\n# 문자열 생성\nprint(\"안녕하세요\")\nprint('Hello')\n\n안녕하세요\nHello\n\n\n\n# 문자열 내부에 따옴표 넣기\nprint('\"안녕하세요\"라고 말했습니다.')\nprint(\"'날씨가 좋다'라고 생각했습니다.\")\n\n\"안녕하세요\"라고 말했습니다.\n'날씨가 좋다'라고 생각했습니다.\n\n\n\n# 이스케이프 문자 사용1\nprint(\"\\\"안녕하세요\\\"라고 말했습니다.\")\nprint('\\'날씨가 좋다\\'라고 생각했습니다.')\n\n\"안녕하세요\"라고 말했습니다.\n'날씨가 좋다'라고 생각했습니다.\n\n\n\n# 이스케이프 문자 사용2\nprint(\"Hello\\nWorld\")\n\nHello\nWorld\n\n\n\n# 이스케이프 문자 사용3\nprint(\"Hello\\tWorld\")\n\nHello   World\n\n\n\n# 여러 줄 문자열 만들기 : 세 번 반복한 따옴표로 감쌈\nprint(\"\"\"동해물과 백두산이 마르고 닳도록\n하느님이 보우하사 우리나라 만세\n무궁화 삼천리 화려강산\n대한사람 대한으로 길이 보전하세\"\"\")\n\n동해물과 백두산이 마르고 닳도록\n하느님이 보우하사 우리나라 만세\n무궁화 삼천리 화려강산\n대한사람 대한으로 길이 보전하세"
  },
  {
    "objectID": "4_string.html#문자열-연산",
    "href": "4_string.html#문자열-연산",
    "title": "\n\n문자열 처리\n",
    "section": "4.2. 문자열 연산",
    "text": "4.2. 문자열 연산\n\n문자열 연결 연산자 + : 두 문자열을 연결해서 새로운 문자열 생성\n문자열 반복 연산자 * : 문자열을 숫자만큼 반복하여 새로운 문자열 생성 - (예) 문자열*숫자\n\n\n\n# 문자열 연결\nprint(\"Hello \" + \"Wolrld\")\n\nHello Wolrld\n\n\n\n# 문자열 연결 연산자는 문자열과 숫자를 연결할 수 없음\n#score = 99\n#print(\"성적은\" + score + \"입니다.\")\n\n\n# 문자열 연결 연산자로 문자열과 숫자를 연결하려면 숫자를 문자열로 변환해야 함\nscore = 99\nprint(\"성적은\" + str(score) + \"입니다.\")\n\n성적은99입니다.\n\n\n\n# 문자열 반복\nprint(\"Hello \" * 3)\n\nHello Hello Hello"
  },
  {
    "objectID": "4_string.html#인덱싱과-슬라이싱",
    "href": "4_string.html#인덱싱과-슬라이싱",
    "title": "\n\n문자열 처리\n",
    "section": "4.3. 인덱싱과 슬라이싱",
    "text": "4.3. 인덱싱과 슬라이싱\n\n문자열의 각 문자에 접근할 때 문자 위치인 인덱스(index)를 사용함\n\nPython은 숫자를 0부터 세는 제로 인덱스(zero index) 유형을 사용함\n\n\n\n\n인덱싱(indexing)\n\n[index]를 사용하여 문자열의 특정 위치에 있는 항목(문자)에 접근하는 것\n리버스 인덱싱(reverse indexing) : 음수 인덱스를 사용하면 마지막 값부터 -1씩 감소하여 역순으로 접근할 수 있음\n\n\n\n\n슬라이싱(slicing)\n\n[(start index):(stop index)]를 이용하여 문자열의 일부 문자를 추출하는 것\n끝 인덱스는 포함하지 않으니 주의해야 함\n시작 인덱스를 생략하면 첫 번째 글자부터 추출하며, 끝 인덱스를 생략하면 가장 마지막 글자까지 추출함\n\n\n\n\n\n\n# 문자열 인덱싱1\ns = \"안녕하세요\"\nprint(s[0])\n\n안\n\n\n\n# 문자열 인덱싱2\ns = \"안녕하세요\"\nprint(s[-1])\n\n요\n\n\n\n# 문자열 슬라이싱1\ns = \"안녕하세요\"\nprint(s[0:2])\n\n안녕\n\n\n\n# 문자열 슬라이싱2\ns = \"안녕하세요\"\nprint(s[:2])\nprint(s[2:])\nprint(s[::2])\n\n안녕\n하세요\n안하요\n\n\n\n# 문자열은 불변형 객체이므로 인덱스를 이용한 수정은 불가능함\n#s = \"안녕하세요\"\n#s[2:5] = \"하십니까\"\n#print(s)\n\n\n# 문자열을 변경하려면 새로운 문자열을 만들어야 함\ns = \"안녕하세요\"\ns = s[:2] + \"하십니까\"\nprint(s)\n\n안녕하십니까\n\n\n\n# 문자열 거꾸로 출력하기\nmy_str = \"Hello Python!\"\nprint(my_str[::-1])\n\n!nohtyP olleH"
  },
  {
    "objectID": "4_string.html#문자열-함수",
    "href": "4_string.html#문자열-함수",
    "title": "\n\n문자열 처리\n",
    "section": "4.4. 문자열 함수",
    "text": "4.4. 문자열 함수\n\n4.4.1. 문자열 길이\n\nlen() 함수 : 문자열에 들어있는 문자의 개수(문자열의 길이) 반환\n\n\n\n# 문자열 길이\ns = \"안녕하세요\"\nprint(len(s))\n\n5\n\n\n\n\n\n4.4.2. 대소문자 변환\n\n\n\n함수\n설명\n\n\n\n\nlower()\n문자열의 알파벳을 모두 소문자로 변환\n\n\nupper()\n문자열의 알파벳을 모두 대문자로 변환\n\n\n\n\n\n# 대소문자 변환 : 원본은 변하지 않음\ns = \"Hello Python!\"\nprint(s.lower())\nprint(s.upper())\nprint(s)\n\nhello python!\nHELLO PYTHON!\nHello Python!\n\n\n\n\n\n4.4.3. 문자열 찾기\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nfind()\n- 문자열에서 특정 문자열을 왼쪽에서부터 찾아서 인덱스를 반환 - 찾는 문자열이 없으면 -1을 반환\n\n\nrfind()\n- 문자열에서 특정 문자열을 오른쪽에서부터 찾아서 인덱스를 반환 - 찾는 문자열이 없으면 -1을 반환\n\n\ncount()\n- 문자열에서 특정 문자열의 개수를 반환\n\n\nin 연산자\n- 문자열 내부에 특정 문자열이 있다면 True, 없다면 False를 반환\n\n\n\n\n\n# 문자열 찾기\ns = \"Hello! Python is Python\"\nprint(s.find(\"Python\"))\nprint(s.rfind(\"Python\"))\nprint(s.count(\"Python\"))\nprint(\"Hello\" in s)\nprint(\"Hi\" in s)\n\n7\n17\n2\nTrue\nFalse\n\n\n\n\n4.4.4. 공백 제거 및 문자열 변경\n\n\n\n함수\n설명\n\n\n\n\nstrip()\n문자열 양 옆의 공백이나 특정 문자를 제거\n\n\nrstrip()\n문자열 오른쪽의 공백이나 특정 문자를 제거\n\n\nlstrip()\n문자열 왼쪽의 공백이나 특정 문자를 제거\n\n\nreplace()\n특정 문자열을 다른 문자열로 변경\n\n\n\n\n\n# 공백 제거\ns = \"  Hello Python!  \"\nprint(s)\nprint(s.strip())\n\n  Hello Python!  \nHello Python!\n\n\n\n# 특정 문자 제거\ns = \"##100kg, ##200kg\"\nprint(s.rstrip(\"kg\"))\nprint(s.lstrip(\"#\"))\n\n##100kg, ##200\n100kg, ##200kg\n\n\n\n# 문자열 변경\ns = \"Hello Python!\"\nprint(s.replace(\"Hello\", \"Hi\"))\n\nHi Python!\n\n\n\n\n\n4.4.5. 문자열 분리 및 결합\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nsplit()\n- 특정문자를 기준으로 문자열을 분리하고 리스트로 반환\n\n\njoin()\n- 여러 문자열을 모아서 하나의 문자열로 만듬 - 문자열을 구분할 구분자를 지정해야 함\n\n\n\n\n\n# 문자열 분리\ns = \"Hello Python!\"\ns.split(\" \")\n\n['Hello', 'Python!']\n\n\n\n# 문자열 결합\nlst = [\"one\", \"two\", \"three\"]\nprint(\", \".join(lst))\nprint(\" - \".join(lst))\n\none, two, three\none - two - three\n\n\n\n\n\n4.4.6. 문자열 구성 파악\n\n\n\n함수\n설명\n\n\n\n\nisdigit()\n문자열이 숫자로만 구성되었는지 확인\n\n\nisalpha()\n문자열이 알파벳으로만 구성되었는지 확인\n\n\nisalnum()\n문자열이 알파벳과 숫자로만 구성되었는지 확인\n\n\nislower()\n문자열이 소문자로만 구성되었는지 확인\n\n\nisupper()\n문자열이 대문자로만 구성되었는지 확인\n\n\nisspace()\n문자열이 공백으로만 구성되었는지 확인\n\n\n\n\n\n# 문자열 구성 파악\nprint(\"1234\".isdigit())\nprint(\"Python\".isalpha())\nprint(\"pass123\".isalnum())\nprint(\"hello\".islower())\nprint(\"HELLO\".isupper())\nprint(\"     \".isspace())\n\nTrue\nTrue\nTrue\nTrue\nTrue\nTrue\n\n\n\n\n\n\n4.4.7. 형 변환\n\n\n\n함수\n설명\n\n\n\n\nstr()\n수를 문자열로 변환\n\n\nint()\n정수 형식의 문자열이나 실수를 정수로 변환\n\n\nfloat()\n실수 형식의 문자열이나 정수를 실수로 변환\n\n\n\n\n\n# 형 변환1\na = 1234\n#print(a + \"kg\")\nprint(str(a) + \"kg\")\n\n1234kg\n\n\n\n# 형 변환2\nprint(int(\"1234\"))\nprint(float(\"3.14\"))\n\n1234\n3.14\n\n\n\n\n\n4.4.8. format() 함수\n\n“{자료형}”.format(인수)\n\n\n\n{}를 포함한 문자열 뒤에 .을 찍고 format() 함수를 사용하여 문자열이 출력되는 형식을 지정할 수 있음\n\n앞쪽에 있는 문자열 안의 {} 기호가 format() 함수의 매개변수로 차례로 대치되면서 숫자가 문자열이 됨\n{} 개수와 format() 함수의 매개변수 개수는 반드시 같아야 함\n\nf-string이 format() 함수보다 간단하고 직관적이므로, 대부분 f-string을 사용함\n\n\n\nf-string보다 format() 함수를 사용하는 것이 더 좋은 경우\n\n문자열 내용이 너무 많을 때 - 어떤 데이터를 출력하는지 모아서 볼 수 있어 더 유용함\n데이터를 리스트에 담아서 사용할 때\n\n\n\n\n# format() 함수1\nprint(\"{}\".format(10))\nprint(\"{} {}\".format(10, 20))\nprint(\"{} {} {} {} {}\".format(10, 20, 30, 40, 50))\n\n10\n10 20\n10 20 30 40 50\n\n\n\n# format() 함수2\nname = \"홍길동\"\nage = 20\nprint(f\"이름은 {name}이고, 나이는 {age}입니다.\")\nprint(\"이름은 {}이고, 나이는 {}입니다.\".format(name, age))\n\n이름은 홍길동이고, 나이는 20입니다.\n이름은 홍길동이고, 나이는 20입니다.\n\n\n\n# format() 함수3\na = 4\nb = 3.14159265\nprint(\"20{:02d}\".format(a))                # a 값을 두자리로 출력하되 앞의 빈곳은 0으로 채움\nprint(\"{:.3f}\".format(b))                  # b 값을 소수점 이하 세자리로 반올림하여 출력\n\n2004\n3.142\n\n\n\n# 데이터를 리스트에 담아서 사용할 때는 format() 함수를 사용하는 것이 더 좋음\ndata = [\"별\", 2, \"M\", \"Yes\"]\n\n# f-string 사용\nprint(f\"이름: {data[0]}, 나이: {data[1]}, 성별: {data[2]}, 중성화 여부: {data[3]}\")\n\n# format() 함수 사용\n# 전개 연산자 *를 사용하여 리스트 내용을 전개함\nprint(\"이름: {}, 나이: {}, 성별: {}, 중성화 여부: {}\".format(*data))\n\n이름: 별, 나이: 2, 성별: M, 중성화 여부: Yes\n이름: 별, 나이: 2, 성별: M, 중성화 여부: Yes"
  },
  {
    "objectID": "6_pandas.html",
    "href": "6_pandas.html",
    "title": "\n\nPandas\n",
    "section": "",
    "text": "Pandas"
  },
  {
    "objectID": "6_pandas.html#판다스-객체",
    "href": "6_pandas.html#판다스-객체",
    "title": "\n\nPandas\n",
    "section": "6.1. 판다스 객체",
    "text": "6.1. 판다스 객체\n\n6.1.1. 판다스 객체 생성\n\nPandas\n\nNumPy를 기반으로 만들어진 데이터 분석용 라이브러리\n레이블(label)로 식별되는 데이터를 쉽게 다룰 수 있도록 지원\n고성능 데이터 조작, 탐색, 전처리, 변환, 요약, 통계 연산 기능 제공\n주요 객체로는 Series(1차원), DataFrame(2차원), Index(레이블 관리 구조)가 있음\n\n\n\n\n\n\n\n\n\n\n객체\n설명\n\n\n\n\nSeries\n- 1차원 레이블이 붙은 배열로, 각 데이터에 고유한 인덱스가 있음 - 모든 원소가 동일한 자료형으로 저장되며, 다양한 자료형을 지원\n\n\nDataFrame\n- 2차원 표 형태의 데이터 구조로, 행(row)과 열(column)로 구성됨 - 각 열은 Series로 구성되어 있으며, 서로 다른 자료형을 가질 수 있음 - DataFrame은 정렬된(같은 인덱스 공유) Series 객체의 연속으로 볼 수 있음\n\n\nIndex\n- 데이터에 레이블을 부여하는 객체로, 행 또는 열에 사용됨 - 데이터 정렬, 선택, 결합 등을 효율적으로 할 수 있도록 지원\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\npd.Series()\n1차원 Series 객체 생성\n\n\npd.DataFrame()\n2차원 DataFrame 객체 생성\n\n\npd.Index()\nIndex 객체 생성\n\n\n\n\n\nimport numpy as np\nimport pandas as pd\n\n\n# Series 생성1 : 리스트 사용\nsr = pd.Series([1, 2, 3, 4, 5])\nprint(sr)\n\n0    1\n1    2\n2    3\n3    4\n4    5\ndtype: int64\n\n\n\n# Series 생성2 : 넘파이 배열 사용\nsr = pd.Series(np.array([1, 2, 3, 4, 5]))\nprint(sr)\n\n0    1\n1    2\n2    3\n3    4\n4    5\ndtype: int32\n\n\n\n# Series 생성3 : 딕셔너리 사용\n# 딕셔너리 키는 인덱스로 자동 지정됨\nsr = pd.Series({'a': 10, 'b': 20, 'c': 30})\nprint(sr)\n\na    10\nb    20\nc    30\ndtype: int64\n\n\n\n# Series 생성4 : 인덱스 지정\nsr = pd.Series([1, 2, 3], index = ['a', 'b', 'c'])\nprint(sr)\n\na    1\nb    2\nc    3\ndtype: int64\n\n\n\n# DataFrame 생성1 : Series 사용\nsr = pd.Series([1, 2, 3], index = ['a', 'b', 'c'])\ndf = pd.DataFrame(sr, columns = ['value'])\nprint(df)\n\n   value\na      1\nb      2\nc      3\n\n\n\n# DataFrame 생성2 : 리스트 사용\nlst = [['Alice', 22], ['Bob', 20], ['Charlie', 27]]\ndf = pd.DataFrame(lst, columns=['Name', 'Age'])\nprint(df)\n\n      Name  Age\n0    Alice   22\n1      Bob   20\n2  Charlie   27\n\n\n\n# DataFrame 생성3 : 넘파이 배열 사용\narr = np.array([['Alice', 22], ['Bob', 20], ['Charlie', 27]])\ndf = pd.DataFrame(arr, columns=['Name', 'Age'])\nprint(df)\n\n      Name Age\n0    Alice  22\n1      Bob  20\n2  Charlie  27\n\n\n\n# DataFrame 생성4 : 딕셔너리 사용\n# 딕셔너리 키는 열 이름으로 자동 지정됨\ndct = {'Name': ['Alice', 'Bob', 'Charlie'], 'Age': [22, 20, 27]}\ndf = pd.DataFrame(dct)\nprint(df)\n\n      Name  Age\n0    Alice   22\n1      Bob   20\n2  Charlie   27\n\n\n\n# DataFrame 생성5 : 딕셔너리 + 리스트 컴프리헨션 사용\ndct = [{'a': i, 'b': 2*i} for i in range(3)]\ndf = pd.DataFrame(dct)\nprint(df)\n\n   a  b\n0  0  0\n1  1  2\n2  2  4\n\n\n\n# DataFrame 생성6 : Series 사용\n# 서로 다른 인덱스를 가진 Series로 DataFrame을 생성하면\n# 공통된 인덱스를 기준으로 맞춰지고, 누락된 값은 NaN(Not a Number)으로 채워짐\nsr1 = pd.Series([1, 2, 3], index = ['a', 'b', 'c'])\nsr2 = pd.Series([4, 5, 6], index = ['a', 'c', 'd'])\ndf = pd.DataFrame({'x': sr1, 'y': sr2})\nprint(df)\n\n     x    y\na  1.0  4.0\nb  2.0  NaN\nc  3.0  5.0\nd  NaN  6.0\n\n\n\n# DataFrame 생성7 : 인덱스 및 열 이름 지정\ndata = [[101, 22], [102, 20], [103, 27]]\ncolumns = ['ID', 'Age']\nindex = ['Alice', 'Bob', 'Charlie']\ndf = pd.DataFrame(data, columns=columns, index=index)\nprint(df)\n\n          ID  Age\nAlice    101   22\nBob      102   20\nCharlie  103   27\n\n\n\n# Index 생성1 : 리스트 사용\nidx = pd.Index(['a', 'b', 'c', 'd'])\nidx\n\nIndex(['a', 'b', 'c', 'd'], dtype='object')\n\n\n\n# Index 생성2 : range() 사용\nidx = pd.Index(range(1, 6))\nidx\n\nRangeIndex(start=1, stop=6, step=1)\n\n\n\n\n\n6.1.2. 데이터프레임 속성\n\n\n\n속성\n설명\n\n\n\n\n.shape\n데이터프레임의 모양(행, 열)\n\n\n.index\n행 인덱스 조회 및 변경\n\n\n.columns\n열 이름 조회 및 변경\n\n\n.dtypes\n각 열의 자료형 확인\n\n\n\n\n\n# 데이터프레임 속성\ndf = pd.DataFrame({\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],\n    'Age': [25, 30, 35, 40, 28],\n    'Score': [85.5, 90.3, 78.2, 88.9, 92.5]\n})\n\nprint(df.shape)\nprint(df.index)\nprint(df.columns)\nprint(df.dtypes)\n\n(5, 3)\nRangeIndex(start=0, stop=5, step=1)\nIndex(['Name', 'Age', 'Score'], dtype='object')\nName      object\nAge        int64\nScore    float64\ndtype: object\n\n\n\n# 행 인덱스 변경\ndf.index = ['a', 'b', 'c', 'd', 'e']\nprint(df)\n\n      Name  Age  Score\na    Alice   25   85.5\nb      Bob   30   90.3\nc  Charlie   35   78.2\nd    David   40   88.9\ne      Eva   28   92.5\n\n\n\n# 열 이름 변경\ndf.columns = ['Student Name', 'Student Age', 'Exam Score']\nprint(df)\n\n  Student Name  Student Age  Exam Score\na        Alice           25        85.5\nb          Bob           30        90.3\nc      Charlie           35        78.2\nd        David           40        88.9\ne          Eva           28        92.5\n\n\n\n\n\n6.1.3. 데이터프레임 정보\n\n\n\n함수\n설명\n\n\n\n\ninfo()\n기본 정보(행 개수, 열 개수, 데이터 자료형, 결측값 여부 등) 출력\n\n\nhead()\n상위 n개의 행 출력(초기 값 n=5)\n\n\n\n\n\ndf = pd.DataFrame({\n    'Name': ['Alice', 'Bob', 'Charlie', 'David', 'Eva'],\n    'Age': [25, 30, 35, 40, 28],\n    'Score': [85.5, 90.3, 78.2, 88.9, 92.5]\n})\n\n\n# 기본 정보\nprint(df.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 5 entries, 0 to 4\nData columns (total 3 columns):\n #   Column  Non-Null Count  Dtype  \n---  ------  --------------  -----  \n 0   Name    5 non-null      object \n 1   Age     5 non-null      int64  \n 2   Score   5 non-null      float64\ndtypes: float64(1), int64(1), object(1)\nmemory usage: 252.0+ bytes\nNone\n\n\n\n# 상위 5개 행\nprint(df.head())\n\n      Name  Age  Score\n0    Alice   25   85.5\n1      Bob   30   90.3\n2  Charlie   35   78.2\n3    David   40   88.9\n4      Eva   28   92.5"
  },
  {
    "objectID": "6_pandas.html#인덱싱과-슬라이싱",
    "href": "6_pandas.html#인덱싱과-슬라이싱",
    "title": "\n\nPandas\n",
    "section": "6.2. 인덱싱과 슬라이싱",
    "text": "6.2. 인덱싱과 슬라이싱\n\n6.2.1. 열 인덱싱과 슬라이싱\n\n열 이름을 사용하여 직접 선택\n\n여러 개의 열을 선택할 때는 열 이름을 리스트로 작성\n\nloc[:, ] : 레이블(label) 기반 접근 방식\niloc[:, ] : 정수(integer) 기반 접근 방식\n\n\n\ndf = pd.DataFrame({\n    'A': [1, 2, 3],\n    'B': [4, 5, 6],\n    'C': [7, 8, 9],\n    'D': [10, 11, 12]\n}, index=['x', 'y', 'z'])\n\n# 열 인덱싱과 슬라이싱1 : 열 이름 사용\ndf['A']                                      # 열 이름\ndf[['A', 'C']]                               # 열 이름 리스트\n#df['A':'B']                                 # 열 이름 슬라이싱은 안 됨, Error!\n# 열 인덱싱과 슬라이싱2 : 레이블 기반 접근\ndf.loc[:, 'A']                               # 열 이름\ndf.loc[:, ['A', 'C']]                        # 열 이름 리스트\ndf.loc[:, 'A':'B']                           # 열 이름 슬라이싱\ndf.loc[:, 'B'::2]                            # 열 이름 스트라이딩\ndf.loc[:, [True, False, True, True]]         # bool 리스트\n# 열 인덱싱과 슬라이싱3 : 정수 기반 접근\ndf.iloc[:, 0]                                # 정수\ndf.iloc[:, [0, 3]]                           # 정수 리스트\ndf.iloc[:, range(2)]                         # range\ndf.iloc[:, 0:3]                              # 슬라이싱\ndf.iloc[:, 1::2]                             # 스트라이딩\n\n\n\n6.2.2. 행 인덱싱과 슬라이싱\n\nloc[, :] : 레이블(label) 기반 접근 방식\niloc[, :] : 정수(integer) 기반 접근 방식\n\n\n# 행 인덱싱과 슬라이싱1 : 레이블 기반 접근\ndf.loc['x', ]                                # 인덱스 이름\ndf.loc[['x', 'y'], :]                        # 인덱스 이름 리스트\ndf.loc['x':'y', :]                           # 인덱스 이름 슬라이싱\ndf.loc['x'::1, :]                            # 인덱스 이름 스트라이딩\ndf.loc[[True, False, True], :]               # bool 리스트\ndf.loc[list(df['A'] &lt; 3), :]                 # bool 리스트\ndf.loc[df['A'] &lt; 3, :]                       # bool 리스트\n# 행 인덱싱과 슬라이싱2 : 정수 기반 접근\ndf.iloc[0, :]                                # 정수\ndf.iloc[[0, 2], :]                           # 정수 리스트\ndf.iloc[range(2), :]                         # range\ndf.iloc[0:1, :]                              # 슬라이싱\ndf.iloc[1::2, :]                             # 스트라이딩\ndf.iloc[[True, False, True], :]              # bool 리스트 (권장하지 않음)\ndf.iloc[list(df['A'] &lt; 3), :]                # bool 리스트 (권장하지 않음)\n#df.iloc[df['A'] &lt; 3, :]                     # bool 리스트 (Error!)\n# 행 인덱싱과 슬라이싱3 : 정수 기반 접근\ndf.iloc[0]                                   # 정수\ndf.iloc[[0, 2]]                              # 정수 리스트\ndf.iloc[range(2)]                            # range\ndf.iloc[0:1]                                 # 슬라이싱\ndf.iloc[1::2]                                # 스트라이딩\ndf.iloc[[True, False, True]]                 # bool 리스트(권장하지 않음)\ndf.iloc[list(df['A'] &lt; 3)]                   # bool 리스트(권장하지 않음)\n#df.iloc[df['A'] &lt; 3]                        # bool 리스트 (Error!)\n# 행 인덱싱과 슬라이싱4\n# 인덱싱은 열을 참조하는 반면, 슬라이싱은 행을 참조함\n#df[0]                                       # Error!\ndf[0:2]                                      # 권장하지 않음\ndf['x':'y']                                  # 권장하지 않음\ndf[df['A'] &lt; 3]                              # 불리언 인덱싱은 행 단위로 적용됨\n# 행 인덱싱과 슬라이싱5\ndf = pd.DataFrame({\n    'A': [1, 2, 3],\n    'B': [4, 5, 6],\n    'C': [7, 8, 9],\n    'D': [10, 11, 12]})\n\ndf.loc[0:1]                                  # 명시적 인덱스(label) 사용 - 마지막 인덱스 포함\ndf.iloc[0:1]                                 # 암묵적 인덱스(integer) 사용 - 마지막 인덱스 제외\ndf[0:1]                                      # 암묵적 인덱스(integer) 사용, iloc와 동일"
  },
  {
    "objectID": "6_pandas.html#데이터프레임-연산",
    "href": "6_pandas.html#데이터프레임-연산",
    "title": "\n\nPandas\n",
    "section": "6.3. 데이터프레임 연산",
    "text": "6.3. 데이터프레임 연산\n\n6.3.1. 기본 연산\n\nNumPy와 동일하게 벡터화, 브로드캐스팅 모두 지원\n단항 연산: 인덱스와 열 레이블 보존\n이항 연산: 인덱스와 열 레이블을 기준으로 자동 정렬되어 연산\n\n위치가 아닌 동일한 레이블끼리 연산하며, 일치하지 않는 항목은 NaN으로 처리\n\n\n\n\n# 단항 연산1 : Series\nsr = pd.Series([1, 2, 3, 4, 5])\nprint(sr + 2)\n\n0    3\n1    4\n2    5\n3    6\n4    7\ndtype: int64\n\n\n\n# 단항 연산2 : DataFrame\ndf = pd.DataFrame({\n    'x': [1, 2, 3, 4, 5],\n    'y': [11, 12, 13, 14, 15] \n})\nprint(np.log(df))\n\n          x         y\n0  0.000000  2.397895\n1  0.693147  2.484907\n2  1.098612  2.564949\n3  1.386294  2.639057\n4  1.609438  2.708050\n\n\n\n# 이항 연산1 : Series\n# 두 시리즈에 존재하는 모든 행 인덱스를 포함한 결과 생성 (합집합처럼 동작)\nmath = pd.Series({'Alice': 85, 'Bob': 90, 'Charlie': 78})\nenglish = pd.Series({'Alice': 95, 'Charlie': 80, 'David': 88})\nprint(math + english)\n\nAlice      180.0\nBob          NaN\nCharlie    158.0\nDavid        NaN\ndtype: float64\n\n\n\n# 이항 연산2: DataFrame\nmidterm = pd.DataFrame({\n    'math': [85, 90, 78],\n    'science': [88, 92, 79]\n}, index=['Alice', 'Bob', 'Charlie'])\n\nfinal = pd.DataFrame({\n    'math': [95, 88, 82],\n    'english': [95, 80, 88]\n}, index=['Alice', 'Charlie', 'David'])\n\nprint(midterm + final)\n\n         english   math  science\nAlice        NaN  180.0      NaN\nBob          NaN    NaN      NaN\nCharlie      NaN  166.0      NaN\nDavid        NaN    NaN      NaN\n\n\n\n\n\n6.3.2. 연산자 메소드\n\n인덱스와 열 레이블이 일치하지 않아도 연산 가능\n예외 처리가 필요한 경우 기본 연산자보다 안정적임\n\nfill_value 인수를 사용하여 NaN를 다른 값으로 처리 가능\n\n\n\n\n\n\n연산자\n연산자 메소드\n\n\n\n\n+\nadd()\n\n\n-\nsub()\n\n\n*\nmul()\n\n\n/\ndivide()\n\n\n//\nfloordiv()\n\n\n%\nmod()\n\n\n**\npow()\n\n\n\n\n\n# 연산자 메소드1\n# midterm + final과 동일한 결과\nprint(midterm.add(final))\n\n         english   math  science\nAlice        NaN  180.0      NaN\nBob          NaN    NaN      NaN\nCharlie      NaN  166.0      NaN\nDavid        NaN    NaN      NaN\n\n\n\n# 연산자 메소드2\n# 하나의 데이터프레임에만 값이 있는 경우 0으로 처리하고, 둘 다 값이 없으면 NaN 반환\nprint(midterm.add(final, fill_value = 0))\n\n         english   math  science\nAlice       95.0  180.0     88.0\nBob          NaN   90.0     92.0\nCharlie     80.0  166.0     79.0\nDavid       88.0   82.0      NaN\n\n\n\n\n\n6.3.3. 새로운 열 생성\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\nassign()\n기존 데이터프레임을 수정하지 않고, 새로운 열을 추가한 복사본을 반환\n\n\neval()\n수식을 문자열로 작성하여 열 간 계산을 간결하게 수행(직관적인 수식 표현)\n\n\nwhere()\n조건에 따라 서로 다른 값을 선택하여 새로운 열 생성(NumPy 메소드)\n\n\n\n\n\ndf = pd.DataFrame({\n    'product': ['A', 'B', 'C', 'D', 'E'],\n    'price': [100, 200, 150, 300, 250],\n    'quantity': [10, 5, 3, 7, 6]\n})\nprint(df)\n\n  product  price  quantity\n0       A    100        10\n1       B    200         5\n2       C    150         3\n3       D    300         7\n4       E    250         6\n\n\n\n# 새로운 열 생성1: 기본 할당\n# 기본 할당은 데이터를 직접 수정하므로, 권장하지 않음\ndf['total_price'] = df['price'] * df['quantity']\nprint(df)\n\n  product  price  quantity  total_price\n0       A    100        10         1000\n1       B    200         5         1000\n2       C    150         3          450\n3       D    300         7         2100\n4       E    250         6         1500\n\n\n\n# 새로운 열 생성2: assign() 사용\nprint(df.assign(total_price = df['price'] * df['quantity']))\n\n  product  price  quantity  total_price\n0       A    100        10         1000\n1       B    200         5         1000\n2       C    150         3          450\n3       D    300         7         2100\n4       E    250         6         1500\n\n\n\n# 새로운 열 생성3: eval() 사용\n# inplace=True: 기존 데이터프레임에 직접 적용(새 객체를 반환하지 않음)\ndf.eval('total_price = price * quantity', inplace=True)\nprint(df)\n\n  product  price  quantity  total_price\n0       A    100        10         1000\n1       B    200         5         1000\n2       C    150         3          450\n3       D    300         7         2100\n4       E    250         6         1500\n\n\n\n# 새로운 열 생성4: where() 사용\n# 가격이 200 이상이면 'Expensive', 아니면 'Affordable'로 구분\ndf['price_category'] = np.where(df['price'] &gt;= 200, 'Expensive', 'Affordable')\nprint(df)\n\n  product  price  quantity  total_price price_category\n0       A    100        10         1000     Affordable\n1       B    200         5         1000      Expensive\n2       C    150         3          450     Affordable\n3       D    300         7         2100      Expensive\n4       E    250         6         1500      Expensive\n\n\n\n\n\n6.3.4. 데이터프레임 집계\n\nNumPy와 동일한 축 개념 사용\n\naxis 0 : 행 방향 연산(열 단위로 요약)\naxis 1 : 열 방향 연산(행 단위로 요약)\n\n수치형 데이터에 적용되며, NaN은 기본적으로 제외됨\n\n\n\n\n\n함수\n설명\n\n\n\n\ncount()\nNaN를 제외한 행의 개수\n\n\nvalue_counts()\n집단별 빈도\n\n\ndescribe()\n요약 통계량\n\n\nsum()\n합계\n\n\nmean()\n평균\n\n\nstd()\n표준편차\n\n\nmedian()\n중앙값\n\n\nmin(), max()\n최소값, 최대값\n\n\ncumsum(), cumprod()\n누적 합계, 누적 곱\n\n\n\n\n\n## 실습 데이터 : tips 데이터셋\nimport seaborn as sns\ntips = sns.load_dataset('tips')\n\n\n# total_bill: 식사 금액\n# tip: 팁 금액\n# sex: 성별\n# smoker: 흡연 여부\n# day: 요일\n# time: 식사 시간(Lunch, Dinner)\n# size: 식사 인원 수\nprint(tips.info())\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 244 entries, 0 to 243\nData columns (total 7 columns):\n #   Column      Non-Null Count  Dtype   \n---  ------      --------------  -----   \n 0   total_bill  244 non-null    float64 \n 1   tip         244 non-null    float64 \n 2   sex         244 non-null    category\n 3   smoker      244 non-null    category\n 4   day         244 non-null    category\n 5   time        244 non-null    category\n 6   size        244 non-null    int64   \ndtypes: category(4), float64(2), int64(1)\nmemory usage: 7.4 KB\nNone\n\n\n\nprint(tips.head())\n\n   total_bill   tip     sex smoker  day    time  size\n0       16.99  1.01  Female     No  Sun  Dinner     2\n1       10.34  1.66    Male     No  Sun  Dinner     3\n2       21.01  3.50    Male     No  Sun  Dinner     3\n3       23.68  3.31    Male     No  Sun  Dinner     2\n4       24.59  3.61  Female     No  Sun  Dinner     4\n\n\n\nprint(tips.describe())\n\n       total_bill         tip        size\ncount  244.000000  244.000000  244.000000\nmean    19.785943    2.998279    2.569672\nstd      8.902412    1.383638    0.951100\nmin      3.070000    1.000000    1.000000\n25%     13.347500    2.000000    2.000000\n50%     17.795000    2.900000    2.000000\n75%     24.127500    3.562500    3.000000\nmax     50.810000   10.000000    6.000000\n\n\n\n# 각 열의 유효한 데이터 수 (NaN 제외)\nprint(tips.count())\n\ntotal_bill    244\ntip           244\nsex           244\nsmoker        244\nday           244\ntime          244\nsize          244\ndtype: int64\n\n\n\n# 식사 시간별 주문 수\nprint(tips.value_counts('time'))\n\ntime\nDinner    176\nLunch      68\nName: count, dtype: int64\n\n\n\n# 전체(합계) 식사 금액, 팁 금액, 식사 인원 수\nprint(tips[['total_bill', 'tip', 'size']].sum())\n\ntotal_bill    4827.77\ntip            731.58\nsize           627.00\ndtype: float64\n\n\n\n# 고객 1인당 평균 식사 금액\nprint((tips['total_bill'] / tips['size']).mean())\n\n7.888229508196722\n\n\n\n# 고객 1인당 평균 팁 금액\nprint((tips['tip'] / tips['size']).mean())\n\n1.2127616120218578\n\n\n\n# 전체 식사 금액에서 팁이 차지하는 비율\nprint(tips['tip'] / tips['total_bill'])\n\n0      0.059447\n1      0.160542\n2      0.166587\n3      0.139780\n4      0.146808\n         ...   \n239    0.203927\n240    0.073584\n241    0.088222\n242    0.098204\n243    0.159744\nLength: 244, dtype: float64\n\n\n\n# 전체 식사 금액에서 팁이 차지하는 비율에 대한 요약 통계량\nprint((tips['tip'] / tips['total_bill']).describe())\n\ncount    244.000000\nmean       0.160803\nstd        0.061072\nmin        0.035638\n25%        0.129127\n50%        0.154770\n75%        0.191475\nmax        0.710345\ndtype: float64\n\n\n\n# 전체 식사 금액에서 팁이 차지하는 비율이 50% 이상인 경우\nprint(tips[tips['tip'] / tips['total_bill'] &gt;= 0.5])\n\n     total_bill   tip   sex smoker  day    time  size\n172        7.25  5.15  Male    Yes  Sun  Dinner     2"
  },
  {
    "objectID": "6_pandas.html#고급-데이터-처리",
    "href": "6_pandas.html#고급-데이터-처리",
    "title": "\n\nPandas\n",
    "section": "6.4. 고급 데이터 처리",
    "text": "6.4. 고급 데이터 처리\n\n6.4.1. 집단별 연산\n\ngroupby() 함수를 이용하여 특정 열을 기준으로 데이터를 집단화한 후, 다양한 연산 수행 가능\nSQL의 GROUP BY와 유사한 기능을 제공하며, 집계, 변환, 필터링을 지원\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\naggregate() 또는 agg()\n여러 집계 함수를 동시에 적용(문자열, 함수, 리스트 등 가능)\n\n\nfilter()\n집단별 집계 결과를 조건으로 집단 자체를 필터링\n\n\ntransform()\n집단별 연산 결과를 원래 구조와 같은 형태로 반환(원소 개수 유지)\n\n\napply()\n임의의 함수를 전체 집단에 유연하게 적용(집계, 반환 모두 가능)\n\n\n\n\n\n#  실습 데이터 : tips 데이터셋\ntips = sns.load_dataset('tips')\n\n\n# 요일별 평균 식사 금액\n# observed=False: 모든 범주 포함, 실제 데이터가 없으면 NaN\nprint(tips.groupby('day', observed=False)['total_bill'].mean())\n\nday\nThur    17.682742\nFri     17.151579\nSat     20.441379\nSun     21.410000\nName: total_bill, dtype: float64\n\n\n\n# 식사 시간별 식사 금액, 팁 금액의 평균 및 표준편차\nprint(tips.groupby('time', observed=False)[['total_bill', 'tip']].agg(['mean', 'std']))\n\n       total_bill                 tip          \n             mean       std      mean       std\ntime                                           \nLunch   17.168676  7.713882  2.728088  1.205345\nDinner  20.797159  9.142029  3.102670  1.436243\n\n\n\n# 식사 시간별 식사 금액의 최대값, 팁 금액의 최소값: 딕셔너리 사용\nprint(tips.groupby('time', observed=False).agg({'total_bill': 'max', 'tip': 'min'}).reset_index())\n\n     time  total_bill   tip\n0   Lunch       43.11  1.25\n1  Dinner       50.81  1.00\n\n\n\n# 식사 시간별 식사 금액의 최대값, 팁 금액의 최소값: 튜플 사용, named aggregation 문법\nprint(tips.groupby('time', observed=False).agg(total_bill_max = ('total_bill', 'max'), tip_min = ('tip', 'min')).reset_index())\n\n     time  total_bill_max  tip_min\n0   Lunch           43.11     1.25\n1  Dinner           50.81     1.00\n\n\n\n\n[참고] 람다 함수(lamdba function)\n\n함수 이름 없이 일시적으로 정의해 사용할 수 있는 익명 함수\ndef, return 없이 간단한 함수 로직을 한 줄로 표현\n구조는 일반 함수와 같지만, 주로 짧고 단순한 연산에 사용\napply(), filter() 등 함수의 인수로 전달할 때 유용하게 활용\n\n\n\n\n# 함수 정의\ndef f(x, y):\n    return x + y\nf(1, 4)\n\n5\n\n\n\n# 람다 함수\n(lambda x, y: x + y)(1, 4)\n\n5\n\n\n\n# 팀 금액 평균이 3달러 이상인 요일 데이터 필터링: 함수 정의\ndef filter_tip_avg(x):\n    return x['tip'].mean() &gt;= 3\n\nprint(tips.groupby('day', observed=False).filter(filter_tip_avg))\n\n     total_bill   tip     sex smoker  day    time  size\n0         16.99  1.01  Female     No  Sun  Dinner     2\n1         10.34  1.66    Male     No  Sun  Dinner     3\n2         21.01  3.50    Male     No  Sun  Dinner     3\n3         23.68  3.31    Male     No  Sun  Dinner     2\n4         24.59  3.61  Female     No  Sun  Dinner     4\n..          ...   ...     ...    ...  ...     ...   ...\n186       20.90  3.50  Female    Yes  Sun  Dinner     3\n187       30.46  2.00    Male    Yes  Sun  Dinner     5\n188       18.15  3.50  Female    Yes  Sun  Dinner     3\n189       23.10  4.00    Male    Yes  Sun  Dinner     3\n190       15.69  1.50    Male    Yes  Sun  Dinner     2\n\n[76 rows x 7 columns]\n\n\n\n# 팀 금액 평균이 3달러 이상인 요일 데이터 필터링: 람다 함수 사용\nprint(tips.groupby('day', observed=False).filter(lambda x: x['tip'].mean() &gt;= 3))\n\n     total_bill   tip     sex smoker  day    time  size\n0         16.99  1.01  Female     No  Sun  Dinner     2\n1         10.34  1.66    Male     No  Sun  Dinner     3\n2         21.01  3.50    Male     No  Sun  Dinner     3\n3         23.68  3.31    Male     No  Sun  Dinner     2\n4         24.59  3.61  Female     No  Sun  Dinner     4\n..          ...   ...     ...    ...  ...     ...   ...\n186       20.90  3.50  Female    Yes  Sun  Dinner     3\n187       30.46  2.00    Male    Yes  Sun  Dinner     5\n188       18.15  3.50  Female    Yes  Sun  Dinner     3\n189       23.10  4.00    Male    Yes  Sun  Dinner     3\n190       15.69  1.50    Male    Yes  Sun  Dinner     2\n\n[76 rows x 7 columns]\n\n\n\n# 성별 팁 금액의 편차\ntips['tip_dev'] = tips.groupby('sex', observed=False)['tip'].transform(lambda x: x - x.mean())\nprint(tips[['sex', 'tip', 'tip_dev']].head())\n\n      sex   tip   tip_dev\n0  Female  1.01 -1.823448\n1    Male  1.66 -1.429618\n2    Male  3.50  0.410382\n3    Male  3.31  0.220382\n4  Female  3.61  0.776552\n\n\n\n# 식사 시간별 팁 금액의 사분위수범위: 함수 정의\ndef iqr(x):\n    return x.quantile(0.75) - x.quantile(0.25)\n\nprint(tips.groupby('time', observed=False)['tip'].apply(iqr))\n\ntime\nLunch     1.2875\nDinner    1.6875\nName: tip, dtype: float64\n\n\n\n# 식사 시간별 팁 금액의 사분위수범위: 람다 함수 사용\nprint(tips.groupby('time', observed=False)['tip'].apply(lambda x: x.quantile(0.75) - x.quantile(0.25)))\n\ntime\nLunch     1.2875\nDinner    1.6875\nName: tip, dtype: float64\n\n\n\n\n\n6.4.2. 표현식 기반 처리\n\neval(), query() 메소드를 사용하면 문자열 형태의 표현식을 통해 데이터를 보다 직관적으로 처리 가능\n복잡한 연산이나 조건 필터링을 간결하게 표현할 수 있어 가독성과 성능 모두에 유리함\n\n데이터프레임의 열 이름을 따옴표 없이 사용 가능\n외부 변수는 @ 기호를 사용하여 표현식에 표현 가능\n\n\n\n\n\n\n\n\n\n\n함수\n설명\n\n\n\n\neval()\n- 문자열로 작성한 수식을 이용하여 기존 열을 연산하거나 새로운 열을 생성 - Python 표현식을 그대로 사용할 수 있어 가독성이 높음\n\n\nquery()\n- 문자열로 작성한 조건식을 이용하여 행을 필터링- 복잡한 불리언 인덱싱보다 간결하고 직관적인 문법 제공 - 논리 연산자는 &, \\|, ~의 사용을 권장하며, 각 조건은 괄호 ()로 감싸야 함\n\n\n\n\n\n#  실습 데이터 : tips 데이터셋\ntips = sns.load_dataset('tips')\n\n\n# 기존 열 연산: 식사 금액에서 세금 10%를 제외한 실수령 금액\nprint(tips.eval('total_bill = total_bill * 0.9'))\n\n     total_bill   tip     sex smoker   day    time  size\n0        15.291  1.01  Female     No   Sun  Dinner     2\n1         9.306  1.66    Male     No   Sun  Dinner     3\n2        18.909  3.50    Male     No   Sun  Dinner     3\n3        21.312  3.31    Male     No   Sun  Dinner     2\n4        22.131  3.61  Female     No   Sun  Dinner     4\n..          ...   ...     ...    ...   ...     ...   ...\n239      26.127  5.92    Male     No   Sat  Dinner     3\n240      24.462  2.00  Female    Yes   Sat  Dinner     2\n241      20.403  2.00    Male    Yes   Sat  Dinner     2\n242      16.038  1.75    Male     No   Sat  Dinner     2\n243      16.902  3.00  Female     No  Thur  Dinner     2\n\n[244 rows x 7 columns]\n\n\n\n# 새로운 열 생성: 전체 식사 금액 대비 팁 금액 비율\n# inplace=True: 기존 데이터프레임에 직접 적용(새 객체를 반환하지 않음)\ntips.eval('tip_rate = tip / total_bill', inplace=True)\nprint(tips)\n\n     total_bill   tip     sex smoker   day    time  size  tip_rate\n0         16.99  1.01  Female     No   Sun  Dinner     2  0.059447\n1         10.34  1.66    Male     No   Sun  Dinner     3  0.160542\n2         21.01  3.50    Male     No   Sun  Dinner     3  0.166587\n3         23.68  3.31    Male     No   Sun  Dinner     2  0.139780\n4         24.59  3.61  Female     No   Sun  Dinner     4  0.146808\n..          ...   ...     ...    ...   ...     ...   ...       ...\n239       29.03  5.92    Male     No   Sat  Dinner     3  0.203927\n240       27.18  2.00  Female    Yes   Sat  Dinner     2  0.073584\n241       22.67  2.00    Male    Yes   Sat  Dinner     2  0.088222\n242       17.82  1.75    Male     No   Sat  Dinner     2  0.098204\n243       18.78  3.00  Female     No  Thur  Dinner     2  0.159744\n\n[244 rows x 8 columns]\n\n\n\n# 외부 변수 사용: 전체 식사 금액에 따른 기본(최소) 팁 금액\ntip_percentage = 0.15\ntips.eval('min_tip = total_bill * @tip_percentage', inplace = True)\nprint(tips)\n\n     total_bill   tip     sex smoker   day    time  size  tip_rate  min_tip\n0         16.99  1.01  Female     No   Sun  Dinner     2  0.059447   2.5485\n1         10.34  1.66    Male     No   Sun  Dinner     3  0.160542   1.5510\n2         21.01  3.50    Male     No   Sun  Dinner     3  0.166587   3.1515\n3         23.68  3.31    Male     No   Sun  Dinner     2  0.139780   3.5520\n4         24.59  3.61  Female     No   Sun  Dinner     4  0.146808   3.6885\n..          ...   ...     ...    ...   ...     ...   ...       ...      ...\n239       29.03  5.92    Male     No   Sat  Dinner     3  0.203927   4.3545\n240       27.18  2.00  Female    Yes   Sat  Dinner     2  0.073584   4.0770\n241       22.67  2.00    Male    Yes   Sat  Dinner     2  0.088222   3.4005\n242       17.82  1.75    Male     No   Sat  Dinner     2  0.098204   2.6730\n243       18.78  3.00  Female     No  Thur  Dinner     2  0.159744   2.8170\n\n[244 rows x 9 columns]\n\n\n\n# 기본(최소) 팁 금액보다 적게 준 경우 'Below', 많거나 같은 경우 'Above'로 구분\n# 기본(최소) 팁 금액보다 적게 준 경우는 108팀임\ntips['tip_group'] = np.where(tips['tip'] &lt; tips['min_tip'], 'Below', 'Above')\nprint(tips['tip_group'].value_counts())\n\ntip_group\nAbove    136\nBelow    108\nName: count, dtype: int64\n\n\n\n# 단일 조건 필터링: 식사 금액이 20달러 이상인 경우\nprint(tips.query('total_bill &gt;= 20'))\n\n     total_bill   tip     sex smoker  day    time  size  tip_rate  min_tip  \\\n2         21.01  3.50    Male     No  Sun  Dinner     3  0.166587   3.1515   \n3         23.68  3.31    Male     No  Sun  Dinner     2  0.139780   3.5520   \n4         24.59  3.61  Female     No  Sun  Dinner     4  0.146808   3.6885   \n5         25.29  4.71    Male     No  Sun  Dinner     4  0.186240   3.7935   \n7         26.88  3.12    Male     No  Sun  Dinner     4  0.116071   4.0320   \n..          ...   ...     ...    ...  ...     ...   ...       ...      ...   \n237       32.83  1.17    Male    Yes  Sat  Dinner     2  0.035638   4.9245   \n238       35.83  4.67  Female     No  Sat  Dinner     3  0.130338   5.3745   \n239       29.03  5.92    Male     No  Sat  Dinner     3  0.203927   4.3545   \n240       27.18  2.00  Female    Yes  Sat  Dinner     2  0.073584   4.0770   \n241       22.67  2.00    Male    Yes  Sat  Dinner     2  0.088222   3.4005   \n\n    tip_group  \n2       Above  \n3       Below  \n4       Below  \n5       Above  \n7       Below  \n..        ...  \n237     Below  \n238     Below  \n239     Above  \n240     Below  \n241     Below  \n\n[97 rows x 10 columns]\n\n\n\n# 다중 조건 필터링: 식사 인원 수가 3명 이상이고, 목요일에 방문한 경우\n#print(tips.query('size &gt;= 3 and day == \"Thur\"'))           # 권장하지 않음, 조건이 복잡할 경우 오류가 발생할 수 있음\nprint(tips.query('(size &gt;= 3) & (day == \"Thur\")'))          # 권장 방식: 괄호로 각 조건을 명확히 구분\n\n     total_bill   tip     sex smoker   day   time  size  tip_rate  min_tip  \\\n77        27.20  4.00    Male     No  Thur  Lunch     4  0.147059   4.0800   \n85        34.83  5.17  Female     No  Thur  Lunch     4  0.148435   5.2245   \n119       24.08  2.92  Female     No  Thur  Lunch     4  0.121262   3.6120   \n125       29.80  4.20  Female     No  Thur  Lunch     6  0.140940   4.4700   \n129       22.82  2.18    Male     No  Thur  Lunch     3  0.095530   3.4230   \n141       34.30  6.70    Male     No  Thur  Lunch     6  0.195335   5.1450   \n142       41.19  5.00    Male     No  Thur  Lunch     5  0.121389   6.1785   \n143       27.05  5.00  Female     No  Thur  Lunch     6  0.184843   4.0575   \n146       18.64  1.36  Female     No  Thur  Lunch     3  0.072961   2.7960   \n197       43.11  5.00  Female    Yes  Thur  Lunch     4  0.115982   6.4665   \n200       18.71  4.00    Male    Yes  Thur  Lunch     3  0.213789   2.8065   \n204       20.53  4.00    Male    Yes  Thur  Lunch     4  0.194837   3.0795   \n205       16.47  3.23  Female    Yes  Thur  Lunch     3  0.196114   2.4705   \n\n    tip_group  \n77      Below  \n85      Below  \n119     Below  \n125     Below  \n129     Below  \n141     Above  \n142     Below  \n143     Above  \n146     Below  \n197     Below  \n200     Above  \n204     Above  \n205     Above  \n\n\n\n# 외부 변수 사용: 기준 팁 금액 미만인 경우\nmin_tip_required = 5\nprint(tips.query('tip &lt; @min_tip_required'))\n\n     total_bill   tip     sex smoker   day    time  size  tip_rate  min_tip  \\\n0         16.99  1.01  Female     No   Sun  Dinner     2  0.059447   2.5485   \n1         10.34  1.66    Male     No   Sun  Dinner     3  0.160542   1.5510   \n2         21.01  3.50    Male     No   Sun  Dinner     3  0.166587   3.1515   \n3         23.68  3.31    Male     No   Sun  Dinner     2  0.139780   3.5520   \n4         24.59  3.61  Female     No   Sun  Dinner     4  0.146808   3.6885   \n..          ...   ...     ...    ...   ...     ...   ...       ...      ...   \n238       35.83  4.67  Female     No   Sat  Dinner     3  0.130338   5.3745   \n240       27.18  2.00  Female    Yes   Sat  Dinner     2  0.073584   4.0770   \n241       22.67  2.00    Male    Yes   Sat  Dinner     2  0.088222   3.4005   \n242       17.82  1.75    Male     No   Sat  Dinner     2  0.098204   2.6730   \n243       18.78  3.00  Female     No  Thur  Dinner     2  0.159744   2.8170   \n\n    tip_group  \n0       Below  \n1       Above  \n2       Above  \n3       Below  \n4       Below  \n..        ...  \n238     Below  \n240     Below  \n241     Below  \n242     Below  \n243     Above  \n\n[216 rows x 10 columns]\n\n\n\n# 기준 팁 금액보다 적게 준 경우는 216팀임\nprint(tips.query('tip &lt; @min_tip_required').shape[0])\nprint(len(tips.query('tip &lt; @min_tip_required')))\n\n216\n216"
  },
  {
    "objectID": "8_analysis.html",
    "href": "8_analysis.html",
    "title": "\n\n가설 검정\n",
    "section": "",
    "text": "가설 검정"
  },
  {
    "objectID": "8_analysis.html#통계적-가설-검정",
    "href": "8_analysis.html#통계적-가설-검정",
    "title": "\n\n가설 검정\n",
    "section": "8.1. 통계적 가설 검정",
    "text": "8.1. 통계적 가설 검정\n\n통계적 가설(statistical hypothesis)\n\n연구 대상인 모집단의 특성(모수)에 대해 세운 가설\n기존에 알려진 사실에 기반하지만, 아직 통계적으로 검증되지 않은 설명이나 주장\n귀무가설(null hypothesis; \\(H_0\\))\n\n일반적으로 현재의 상태가 유지되거나, 변화가 없음을 나타냄(효과 없음, 차이 없음)\n수식에서는 = 기호로 표현됨\n예: A약과 B약의 효과는 차이가 없다 (\\(H_0: \\mu_A = \\mu_B\\))\n\n대립가설(alternative hypothesis; \\(H_1\\))\n\n연구자가 입증하고자 하는 가설(효과 있음, 차이 있음)\n수식에서는 &gt;, &lt;, ≠ 기호로 표현됨\n예: A약이 B약보다 효과가 좋다 (\\(H_1: \\mu_A &gt; \\mu_B\\))\n\n\n\n\n\n통계적 가설 검정(statistical hypothesis test)\n\n귀무가설이 참이라고 가정할 때, 수집된 데이터가 귀무가설과 얼마나 일치하는지를 검정하는 과정\n데이터가 귀무가설과 일치하지 않을수록, 대립가설을 지지하는 통계적 근거가 강하다고 판단 → 귀무가설 기각(reject \\(H_0\\))\n(예) 형사 재판에서 피고인 A씨는 무죄일까? 유죄일까?\n\n자백을 하지 않는 한 실제로 범죄를 저질렀는지는 알 수 없다. 증거(데이터)를 통해 무죄인지 유죄인지 판단하자(가설검증).\n모수(실제 범죄행위 여부)에 대한 두 가지 주장 → 이 중 무엇이 귀무가설? 대립가설?\n\nA씨는 실제로 범죄를 저지르지 않았다(무죄)\nA씨는 실제로 범죄를 저질렀다(유죄)\n\n대한민국 헌법 제27조 제4항 - 형사피고인은 유죄의 판결이 확정될 때까지 무죄로 추정된다.\n\n귀무가설 \\(H_0\\) : 실제로 범죄를 저지르지 않았다(무죄)\n대립가설 \\(H_1\\) : 실제로 범죄를 저질렀다(유죄)\n\n무죄를 가정하고 살펴봤을 때, 범죄의 증거가 충분하다면 유죄로 판결함\n\n“무죄를 가정 = 귀무가설이 참이라고 가정”하고 살펴봤을 때,\n“범죄의 증거 = 무죄가 아니라는 증거 = 귀무가설과 일치하지 않는 증거”가 충분하다면\n“유죄로 판결함 = 귀무가설을 기각함”\n\n\n“귀무가설을 기각하지 않는다” 의 의미\n\n귀무가설이 반드시 참이라는 뜻이 아니며, 단지 귀무가설을 유지하는 상태임\n즉 수집된 데이터로는 귀무가설이 틀렸다고 판단할 충분한 증거가 없다는 의미\n\n\n\n\n\n통계적 가설 검정 절차\n\n가설 설정\n유의수준 α 결정\n\n귀무가설이 참인데도 불구하고 이를 잘못 기각하는 최대 허용 확률\n일반적으로 1%, 5%, 10%를 사용함\n\np-value 계산\n\n귀무가설이 참일 때, 관측된 데이터보다 극단적인 데이터가 나올 확률\np-value가 작을수록 데이터가 귀무가설과 일치하지 않는다는 의미\n\n가설 검정 및 의사결정\n\np-value &lt; α : 귀무가설 기각(통계적으로 유의하다; statistical significant)\n가설 검정 결과는 최종적인 의사결정(정책 수립, 제품 출시, 실험 중단 등)의 근거로 활용함"
  },
  {
    "objectID": "8_analysis.html#t-test",
    "href": "8_analysis.html#t-test",
    "title": "\n\n가설 검정\n",
    "section": "8.2. t-test",
    "text": "8.2. t-test\n\n두 집단의 평균 차이를 비교하는 데 사용되는 통계적 검정 방법\n전제 조건\n\n정규성 가정 : 각 집단의 데이터가 정규분포를 따른다고 가정함\n등분산성 가정 : 두 집단의 분산이 같다고 가정함\n\n가설 형태\n\n귀무가설 \\(H_0\\) : 집단1과 집단2의 평균은 같다\n대립가설 \\(H_1\\) : 집단1과 집단2의 평균은 같지 않다(양측검정), 집단1이 집단2보다 평균이 더 크다/작다(단측검정)\n\n\n\n\n\n\n\n\n\n\n구분\n설명\n\n\n\n\n독립표본 t-test\n- 서로 독립된 두 집단의 평균 비교 - (예) 성별에 따른 시험 점수 비교\n\n\n대응표본 t-test\n- 짝지은 두 집단의 평균 비교 - (예) 운동 전과 후의 체중 변화, 일란성 쌍둥이의 책임감 비교\n\n\n\n\n\nimport numpy as np\nimport pandas as pd\n\n\n## 실습 데이터 : penguins 데이터셋\nimport seaborn as sns\npenguins = sns.load_dataset('penguins')\n\n\n# species: 펭귄 종(Adelie, Chinstrap, Gentoo)\n# island: 서식하는 섬(Torgersen, Biscoe, Dream)\n# bill_length_mm: 부리 길이(mm)\n# bill_depth_mm: 부리 깊이(mm)\n# flipper_length_mm: 지느러미 길이(mm)\n# body_mass_g: 체질량(g)\n# sex: 성별(Male, Female)\npenguins.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 344 entries, 0 to 343\nData columns (total 7 columns):\n #   Column             Non-Null Count  Dtype  \n---  ------             --------------  -----  \n 0   species            344 non-null    object \n 1   island             344 non-null    object \n 2   bill_length_mm     342 non-null    float64\n 3   bill_depth_mm      342 non-null    float64\n 4   flipper_length_mm  342 non-null    float64\n 5   body_mass_g        342 non-null    float64\n 6   sex                333 non-null    object \ndtypes: float64(4), object(3)\nmemory usage: 18.9+ KB\n\n\n\n## 독립표본 t-test : Adelie와 Chinstrap의 평균 부리 길이(bill_length_mm) 비교\n## 방법1 : scipy 사용\nfrom scipy.stats import ttest_ind, shapiro, levene\n\n# 1. 두 집단 데이터 (결측치 제거)\nbill_length1 = penguins[penguins['species'] == 'Adelie']['bill_length_mm'].dropna()\nbill_length2 = penguins[penguins['species'] == 'Chinstrap']['bill_length_mm'].dropna()\n\n# 2. 정규성 검정\nstat1, p1 = shapiro(bill_length1)\nstat2, p2 = shapiro(bill_length2)\nprint('[Shapiro-Wilk test]')\nprint(f'Adelie:    W={stat1:.3f}, p-value={p1:.3f}')\nprint(f'Chinstrap: W={stat2:.3f}, p-value={p2:.3f}\\n')\n\n[Shapiro-Wilk test]\nAdelie:    W=0.993, p-value=0.717\nChinstrap: W=0.975, p-value=0.194\n\n\n\n\n# 3. 등분산성 검정\nstat3, p3 = levene(bill_length1, bill_length1)\nprint(\"[Levene's test]\")\nprint(f'F={stat3:.3f}, p-value={p3:.3f}\\n')\n\n[Levene's test]\nF=0.000, p-value=1.000\n\n\n\n\n# 4. 독립표본 t-test\nt_stat, p_val = ttest_ind(bill_length1, bill_length2, equal_var=True)\nprint(f'[Independent t-test]')\nprint(f't={t_stat:.3f}, p-value={p_val:.3f}')\n\n[Independent t-test]\nt=-23.802, p-value=0.000\n\n\n\n## 독립표본 t-test : Adelie와 Chinstrap의 평균 부리 길이(bill_length_mm) 비교\n## 방법2 : statsmodels 사용\nfrom statsmodels.formula.api import ols\n\n# 독립표본 t-test\npenguins2 = penguins[penguins['species']!='Gentoo']\nmodel = ols('bill_length_mm ~ C(species)', data=penguins2).fit()\nprint(model.summary())\n\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:         bill_length_mm   R-squared:                       0.723\nModel:                            OLS   Adj. R-squared:                  0.722\nMethod:                 Least Squares   F-statistic:                     566.5\nDate:                Fri, 01 Aug 2025   Prob (F-statistic):           2.01e-62\nTime:                        15:28:28   Log-Likelihood:                -542.08\nNo. Observations:                 219   AIC:                             1088.\nDf Residuals:                     217   BIC:                             1095.\nDf Model:                           1                                         \nCovariance Type:            nonrobust                                         \n===========================================================================================\n                              coef    std err          t      P&gt;|t|      [0.025      0.975]\n-------------------------------------------------------------------------------------------\nIntercept                  38.7914      0.235    164.997      0.000      38.328      39.255\nC(species)[T.Chinstrap]    10.0424      0.422     23.802      0.000       9.211      10.874\n==============================================================================\nOmnibus:                        0.164   Durbin-Watson:                   2.945\nProb(Omnibus):                  0.921   Jarque-Bera (JB):                0.077\nSkew:                           0.045   Prob(JB):                        0.962\nKurtosis:                       3.020   Cond. No.                         2.42\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n\n\n\n## 대응표본 t-test : 학습 프로그램 참여 전후 평균 시험 점수 비교\nfrom scipy.stats import ttest_rel, shapiro, levene\n\n# 1. 학습 프로그램 참여 전후 시험 점수 데이터\npre_scores = [68, 74, 71, 69, 75, 65, 72, 78, 70, 73, 67, 76, 74, 71, 69, 68, 77, 72, 70, 74]\npost_scores = [72, 78, 75, 74, 80, 68, 75, 83, 75, 77, 70, 80, 78, 75, 73, 72, 82, 76, 74, 78]\ndf = pd.DataFrame({'pre': pre_scores, 'post': post_scores})\n\n# 2. 정규성 검정\nstat1, p1 = shapiro(pre_scores)\nstat2, p2 = shapiro(post_scores)\nprint('[Shapiro-Wilk test]')\nprint(f'Pre_scores:  W={stat1:.3f}, p-value={p1:.3f}')\nprint(f'Post_scores: W={stat2:.3f}, p-value={p2:.3f}\\n')\n\n[Shapiro-Wilk test]\nPre_scores:  W=0.984, p-value=0.975\nPost_scores: W=0.983, p-value=0.966\n\n\n\n\n# 3. 대응표본 t-test\nt_stat, p_val = ttest_rel(pre_scores, post_scores)\nprint(f'[Paired t-test]')\nprint(f't={t_stat:.3f}, p-value={p_val:.3f}')\n\n[Paired t-test]\nt=-28.617, p-value=0.000"
  },
  {
    "objectID": "8_analysis.html#anova",
    "href": "8_analysis.html#anova",
    "title": "\n\n가설 검정\n",
    "section": "8.4. ANOVA",
    "text": "8.4. ANOVA\n\n여러 집단의 평균 차이를 비교하는 데 사용되는 통계적 검정 방법\n전제 조건\n\n정규성 가정 : 각 집단의 데이터가 정규분포를 따른다고 가정함\n등분산성 가정 : 모든 집단의 분산이 동일하다고 가정함\n독립성 가정 : 각 집단의 데이터는 서로 독립적이어야 함\n\n가설 형태\n\n귀무가설 \\(H_0\\) : 모든 집단의 평균은 같다\n대립가설 \\(H_1\\) : 적어도 하나의 집단 평균은 다르다\n\n사후 검정(Post-hoc test)\n\nANOVA 결과에서 유의한 경우, 어떤 집단 간에 차이가 있는지를 확인하기 위해 추가 분석을 수행해야 함\n대표적인 방법으로는 Tukey HSD, Bonferroni 등이 있음\n\n\n\n\n## One-way ANOVA : 암컷 펭귄의 종에 따른 평균 체질량 비교\n## 방법1 : scipy 사용\nfrom scipy.stats import f_oneway\nfrom statsmodels.stats.multicomp import pairwise_tukeyhsd\n\n# 1. 세 집단 데이터 (결측치 제거)\nfemale = penguins[penguins['sex']=='Female']\nbody_mass1 = female[female['species'] == 'Adelie']['body_mass_g'].dropna()\nbody_mass2 = female[female['species'] == 'Chinstrap']['body_mass_g'].dropna()\nbody_mass3 = female[female['species'] == 'Gentoo']['body_mass_g'].dropna()\n\n# 2. 정규성 검정\nstat1, p1 = shapiro(body_mass1)\nstat2, p2 = shapiro(body_mass2)\nstat3, p3 = shapiro(body_mass3)\nprint('[Shapiro-Wilk test]')\nprint(f'Adelie:    W={stat1:.3f}, p-value={p1:.3f}')\nprint(f'Chinstrap: W={stat2:.3f}, p-value={p2:.3f}')\nprint(f'Gentoo:    W={stat3:.3f}, p-value={p3:.3f}\\n')\n\n[Shapiro-Wilk test]\nAdelie:    W=0.977, p-value=0.199\nChinstrap: W=0.963, p-value=0.306\nGentoo:    W=0.981, p-value=0.511\n\n\n\n\n# 3. 등분산성 검정\nstat3, p3 = levene(body_mass1, body_mass2, body_mass3)\nprint(\"[Levene's test]\")\nprint(f'F={stat3:.3f}, p-value={p3:.3f}\\n')\n\n[Levene's test]\nF=0.036, p-value=0.965\n\n\n\n\n# 4. 일원분산분석\nF, p_value = f_oneway(body_mass1, body_mass2, body_mass3)\nprint(f'[One-way ANOVA]')\nprint(f'F={F:.3f}, p-value={p_value:.3f}\\n\\n')\n\n[One-way ANOVA]\nF=393.246, p-value=0.000\n\n\n\n\n\n# 5. 사후 검정 : Tukey HSD 방법 사용\ntukey = pairwise_tukeyhsd(endog=female['body_mass_g'], groups=female['species'], alpha=0.05)\nprint(tukey.summary())\n\n      Multiple Comparison of Means - Tukey HSD, FWER=0.05      \n===============================================================\n  group1    group2   meandiff p-adj    lower     upper   reject\n---------------------------------------------------------------\n   Adelie Chinstrap  158.3703 0.0179   22.3208  294.4197   True\n   Adelie    Gentoo 1310.9058    0.0 1195.6491 1426.1624   True\nChinstrap    Gentoo 1152.5355    0.0 1011.0062 1294.0648   True\n---------------------------------------------------------------\n\n\n\n## One-way ANOVA : 암컷 펭귄의 종에 따른 평균 체질량 비교\n## 방법2 : statsmodels 사용\nimport statsmodels.api as sm\n\n# 4. 일원분산분석\nmodel = ols('body_mass_g ~ C(species)', data=female).fit()\nanova_table = sm.stats.anova_lm(model, typ=2)\nprint(anova_table)\n\n                  sum_sq     df           F        PR(&gt;F)\nC(species)  6.035002e+07    2.0  393.246478  6.775686e-63\nResidual    1.243076e+07  162.0         NaN           NaN"
  },
  {
    "objectID": "8_analysis.html#회귀분석",
    "href": "8_analysis.html#회귀분석",
    "title": "\n\n가설 검정\n",
    "section": "8.5. 회귀분석",
    "text": "8.5. 회귀분석\n\n하나 이상의 독립변수(x)가 종속변수(y)에 미치는 영향력의 크기를 수학적 관계식(모형)으로 추정하는 통계적 검정 방법\n\n독립변수(independent variable) : 다른 변수의 변화를 일으키는 변수\n종속변수(dependent variable) : 다른 변수의 영향으로 변화하는 변수\n\n독립변수가 종속변수에 미치는 영향이 통계적으로 유의한지 검정하고, 이를 바탕으로 새로운 독립변수 값에 대한 종속변수의 값을 예측함\n독립변수 개수에 따른 구분\n\n단순선형 회귀분석\n\n독립변수가 1개인 경우\n모형 : \\(y = \\beta_0 + \\beta_1x + \\epsilon\\)\n\n다중선형 회귀분석\n\n독립변수가 2개 이상인 경우\n모형 : \\(y = \\beta_0 + \\beta_1x_1 + \\beta_2x_2 + \\cdots + \\beta_p x_p + \\epsilon\\)\n\n\n일반적으로 최소제곱추정법(OLS)을 통해 주어진 데이터에 가장 적합한 회귀선을 구함 \\[\\hat{y} = b_0 + b_1x\\] \\[\\hat{y} = b_0 + b_1x+ b_2x_2 + \\cdots + b_p x_p\\]\n잔차(residual) : 관측값과 예측값의 차이, \\(y-\\hat{y}\\)\n결정계수(\\(R^2\\))\n\n회귀모형이 데이터를 얼마나 잘 설명하는지 나타내는 지표\n0에서 1 사이의 값을 가지며, 1에 가까울수록 회귀모형의 설명력이 높음\n\n\n\n\n\n\n## 다중선형 회귀분석 : 펭귄의 체질량에 영향을 미치는 요인\nfrom scipy.stats import pearsonr\n\n# 1. 결측치 제거\npenguins_df = penguins.dropna(axis=0)\n\n# 2. 상관계수\nprint(penguins_df.select_dtypes(include='number').corr())\n\n                   bill_length_mm  bill_depth_mm  flipper_length_mm  \\\nbill_length_mm           1.000000      -0.228626           0.653096   \nbill_depth_mm           -0.228626       1.000000          -0.577792   \nflipper_length_mm        0.653096      -0.577792           1.000000   \nbody_mass_g              0.589451      -0.472016           0.872979   \n\n                   body_mass_g  \nbill_length_mm        0.589451  \nbill_depth_mm        -0.472016  \nflipper_length_mm     0.872979  \nbody_mass_g           1.000000  \n\n\n\n# [참고] 상관분석\nr, p_value = pearsonr(penguins_df['bill_length_mm'], penguins_df['bill_depth_mm'])\nprint(f'\\n[Pearson Correlation between bill length and bill depth]')\nprint(f'r={r:.3f}, p-value={p_value:.3f}\\n\\n')\n\n\n[Pearson Correlation between bill length and bill depth]\nr=-0.229, p-value=0.000\n\n\n\n\n\n# 3. 다중선형 회귀분석\nmodel = ols('body_mass_g ~ C(species) + C(island) + C(sex) + bill_length_mm + bill_depth_mm + flipper_length_mm', data=penguins_df).fit()\nprint(model.summary())\n\n                            OLS Regression Results                            \n==============================================================================\nDep. Variable:            body_mass_g   R-squared:                       0.875\nModel:                            OLS   Adj. R-squared:                  0.872\nMethod:                 Least Squares   F-statistic:                     284.1\nDate:                Fri, 01 Aug 2025   Prob (F-statistic):          1.85e-141\nTime:                        15:28:30   Log-Likelihood:                -2353.6\nNo. Observations:                 333   AIC:                             4725.\nDf Residuals:                     324   BIC:                             4760.\nDf Model:                           8                                         \nCovariance Type:            nonrobust                                         \n===========================================================================================\n                              coef    std err          t      P&gt;|t|      [0.025      0.975]\n-------------------------------------------------------------------------------------------\nIntercept               -1500.0291    575.822     -2.605      0.010   -2632.852    -367.207\nC(species)[T.Chinstrap]  -260.3063     88.551     -2.940      0.004    -434.513     -86.100\nC(species)[T.Gentoo]      987.7614    137.238      7.197      0.000     717.771    1257.752\nC(island)[T.Dream]        -13.1031     58.541     -0.224      0.823    -128.271     102.065\nC(island)[T.Torgersen]    -48.0636     60.922     -0.789      0.431    -167.915      71.788\nC(sex)[T.Male]            387.2243     48.138      8.044      0.000     292.521     481.927\nbill_length_mm             18.1893      7.136      2.549      0.011       4.150      32.229\nbill_depth_mm              67.5754     19.821      3.409      0.001      28.581     106.570\nflipper_length_mm          16.2385      2.939      5.524      0.000      10.456      22.021\n==============================================================================\nOmnibus:                        1.114   Durbin-Watson:                   2.167\nProb(Omnibus):                  0.573   Jarque-Bera (JB):                1.101\nSkew:                           0.139   Prob(JB):                        0.577\nKurtosis:                       2.958   Cond. No.                     7.59e+03\n==============================================================================\n\nNotes:\n[1] Standard Errors assume that the covariance matrix of the errors is correctly specified.\n[2] The condition number is large, 7.59e+03. This might indicate that there are\nstrong multicollinearity or other numerical problems."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]